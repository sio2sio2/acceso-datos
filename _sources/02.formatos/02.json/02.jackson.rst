.. _json-jackson:

Jackson
*******
Otra librería muy utilizada y que tiene la ventaja de que también soporta
:ref:`XML <xml>` es la proporcionada por el `proyecto Jackson
<https://github.com/FasterXML/jackson>`_.

Como :ref:`GSON <json-gson>`, nos permite hacer una conversión automática entre
el modelo de objetos y |JSON| para lo cual podemos definir las clases para
`Tutor`, `Alumno` y `Grupo` exactamente de :ref:`la misma forma <gson-auto>`.
Como en aquel caso, empezaremos por no complicar las cosas: las secuencias son
arrays y los valores son directamente traducibles a un tipo primitivo de |JSON|
(es decir, representaremos la edad y no la fecha de nacimiento).

Para empezar necesitaremos la librería `jackson-databind
<https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind>`_.

.. _json-jackson-basico:

Operativa básica
================

.. _json-jackson-read:

Lectura
-------
El código es muy similar al practicado con `GSON`:

.. code-block:: java
   :emphasize-lines: 2, 8

   Path ruta = Path.of(System.getProperty("user.home"), "grupos.json");
   ObjectMapper mapper = new JsonMapper();

   try  (
       InputStream st = Files.newInputStream(ruta);
       InputStreamReader sr = new InputStreamReader(st);
   ) {
       Grupo[] grupos = mapper.readValue(sr, Grupo[].class);
       Arrays.stream(grupos).forEach(System.out::println);
   }
   catch(IOException err) {
       err.printStackTrace();
   }

Si, en cambio, quisiéramos generar una lista de grupos y no un array:

.. code-block:: java

   TypeReference<List<Grupo>> GrupoLista =  new TypeReference<>(){};
   List<Grupo> grupos = mapper.readValue(sr, GrupoLista);

.. note:: Que los miembros de cada grupo sean un array o una lista es
   absolutamente indiferente: la traducción se hará de igual forma.

.. _json-jackson-write:

Escritura
---------
Por su parte la escritura a un |JSON| desde un modelo de objetos tampoco tiene
excesivas diferencias respecto a lo que encontraríamos en `GSON`:

.. code-block:: java

   public static void main(String[] args) {
       Path ruta = Path.of(System.getProperty("java.io.tmpdir"), "grupos.json");
       ObjectMapper mapper = new ObjectMapper();
       // mapper.enable(SerializationFeature.INDENT_OUTPUT);  // Salida "bonita"

       Grupo[] grupos = {
           new Grupo(
               (short) 1,
               "ESO",
               'B',
               new Tutor("Pepe M.J.", "Matemáticas"),
               new Alumno[] {new Alumno("Pablito", 12), new Alumno("Juanito", 13)}
           ),
           new Grupo(
               (short) 2,
               "ESO",
               'C',
               new Tutor("Pedro J.M.", "Lengua"),
               new Alumno[] {new Alumno("Lola", 13), new Alumno("Manolito", 13)}
           )
       };

       try (
           OutputStream st = Files.newOutputStream(ruta);
           OutputStreamWriter sw = new OutputStreamWriter(st);
       ) {
           mapper.writeValue(sw, grupos);
       }
       catch (IOException err) {
           err.printStackTrace();
       }
   }

Al escribir, es indiferente si usamos arrays o listas.

.. note:: Existe el método ``writeValueAsString`` que devuelve una cadena con el
   |JSON| resultante:

   .. code-block:: java

      String contenido = mapper.writeValueAsString(grupos);

.. _json-jackson-conf:

Configuración del mapeo
=======================
Bajo el epígrafe anterior hemos hecho una traducción muy sencilla en la que no
hemos definido ninguna característica particular para la lectura o la escritura
del |JSON| ni hemos necesitado afinar la traducción de los atributos del objeto:
se llaman igual en Java y en |JSON|, no hemos necesitado evitar ninguno, todos
son traducibles directamente a algún tipo existente en el formato |JSON|.

Lo habitual en cambio es que necesitemos configurar el mapeo y eso es lo que
veremos ahora.

Creación del mapper
-------------------
Cuando queremos configurar las características del mapeo, no debemos crear el
*mapper* directamente como hicimos anteriormente:

.. code-block:: java

   ObjectMapper mapper = new JsonMapper();  // Inmutable, no se puede configurar.

ya que a partir de la versión 3 de *Jackson* `los objetos de mapeos son
inmutables
<https://cowtowncoder.medium.com/jackson-3-0-immutability-w-builders-d9c532860d88>`_
y no pueden configurarse después de haberse creado.

El proceso completo de creación de un mapeo tiene tres fases:

1. Creación de un *Factory* (|JsonFactory|), en
   la que podemos ajustar características de serialización
   (|JsonWriteFeature|) y deserialización
   (|JsonReadFeature|) propias del formato.
2. Creación de un *Builder* (|JsonMapper.Builder|), en la que podremos añadir
   módulos (los veremos más adelante), características generales de serialización
   (|SerializationFeature|) y deserialización (|DeserializationFeature|), y
   complementar la definición las clases del modelo con la técnica del *MixIn*.
3. Creación del *Mapper* propiamente (|JsonMapper|).

Ilustrémoslo:

.. code-block:: java

   JsonFactory factory = JsonFactory.builder()
        .enable(JsonReadFeature.ALLOW_JAVA_COMMENTS)  // Características particulares de de/serialización
        .build();

   // MapperBuilder<?, ?> o JsonMapper.Builder, que es la clase padre.
   MapperBuilder<?, ?> builder = JsonMapper.builder(factory)
        .enable(SerializationFeature.INDENT_OUTPUT)  // Características generales de de/serialización
        .addModule(module)      // Supongamos que hemos definido ese modulo. Ya se tratará más adelante
        .addMixIn(Grupo.class, GrupoMixin.class);   // Mezclamos (ya veremos la utilidad)

    // ObjectMapper o JsonMapper, que es la clase padre.
    ObjectMapper mapper = builder.build();

.. note:: |MapperBuilder| y |ObjectMapper| son clases padre que se comparten con
   otros formatos como |YAML| o |XML|. Si nuestra intención es soportar varios
   formatos, es probable que nos convenga definir ``builder`` y ``mapper`` como
   de estas clases respectivamente en vez de las clases más concretas
   |JsonMapper.Builder| y |JsonMapper|.

Estás tres etapas pueden simplificarse si necesitamos menos configuración. Ya hemos
visto que pueden reducirse a una, si no necesitamos configuración adicional en
absoluto:

.. code-block:: java

   ObjectMapper mapper = new JsonMapper();

O a dos, si no necesitamos añadir características particulares de serialización
o deserialización:

.. code-block:: java
   :emphasize-lines: 1

   MapperBuilder<?, ?> builder = JsonMapper.builder() // No hemos definido factory.
        .enable(SerializationFeature.INDENT_OUTPUT)
        .addModule(module)
        .addMixIn(Grupo.class, GrupoMixin.class);

   ObjectMapper mapper = builder.build();

.. _json-jackson-annotations:

Anotaciones
-----------
Hemos visto muy por encima cómo trasladar objetos a |JSON| y viceversa. La regla
es que cada atributo del objeto se traduce en una propiedad |JSON| con el mismo
nombre y que conserva el mismo valor\ [#]_. Centrémonos en ``Grupo``:

.. code-block:: java

   public class Grupo implements Serializable {

       // Atributos
       private short nivel;
       private String etapa;
       private char grupo;
       private Tutor tutor;
       private Alumno[] miembros;

       // Resto de la implementación
   }

La serialización de un objeto ``Grupo`` será esta:

.. code-block:: json

   {
      "nivel": 1,
      "etapa": "ESO",
      "grupo": "C",
      "tutor": { 
         // Serialización de un tutor
      },
      "miembros": [
         // Serialización de los alumnos
      ]
   }

Ahora bien, ¿cómo puede personalizarse la serialización para cambiar el nombre
de un atributo o no serializarlo? La librería para ello utiliza `anotaciones
<https://www.geeksforgeeks.org/java/annotations-in-java/>`_ que permiten indicar
todos estos particulares:

.. code-block:: java
   :emphasize-lines: 6-7

   public class Grupo implements Serializable {

       // Atributos
       private short nivel;

       @JsonProperty("etapa_educativa")
       private String etapa;
       private char grupo;
       private Tutor tutor;
       private Alumno[] miembros;

       // Resto de la implementación
      
   }

De esta forma logramos que en el |JSON| la propiedad no sea  ``etapa``, sino
``etapa_educativa``. Si nuestra intención fuera que algún atributo no pasará al
archivo, tendríamos que anotarlo con ``@JsonIgnore``. El problema de anotar
directamente la clase es que quizás no nos resulte elegante o directamente no
podamos, porque no dependa de nosotros la definición. Para poder añadir
anotaciones sin modificar la clase original, *Jackson* proporciona un mecanismo:
la mezcla. Para ello podríamos definir aparte otra clase distinta que contenga
exclusivamente los atributos que necesitan anotación:

.. code-block:: java

   public abstract class GrupoMixin {

      @JsonProperty("etapa_educativa")
      private String etapa;
   }

Luego, al definir el mapeo. se declara que deseamos mezclar la clase original
con la clase abstracta anotada:

.. code-block:: java
   :emphasize-lines: 2

   MapperBuilder<?, ?> builder = JsonMapper.builder(factory)
        .addMixIn(Grupo.class, GrupoMixin.class);

Existen otras anotaciones interesante que introduciremos más adelante.

.. note:: Al :ref:`serializar en formato XML <xml-jackson>` con esta librería,
   las anotaciones se vuelven imprescindibles, porque es la única forma de
   indicar, entre otras cosas, si un atributo de la clase será un elemento o un
   atributo |XML|.

.. _json-jackson-no-primitivos:

Traducción de tipos no primitivos
=================================
En el ejemplo anterior todos los atributos de los objetos de *Java* tienen una
correspondencia con un tipo primitivo de |JSON|: cadenas, números, secuencias
(ya sean ``Array`` o :java-util:`ArrayList <ArrayList>`), por lo que no hemos
tenido que preocuparnos en definir cómo debe ser la serialización.

Traducciones predefinidas
-------------------------
Tampoco es necesario definir una traducción específica en otros casos en que no
hay correspondencia, pero *Jackson* nos provee una predeterminada:

**Enumeraciones** (:java-lang:`Enum`),
  Si se pretende que la traducción a  |JSON| sean las constantes de enumeración
  convertidas a cadenas. Por ejemplo, en este caso:

  .. code-block:: java

     public enum Enumeracion {
       UNO,
       DOS;
     }

  los valores se verán como las cadenas *UNO* o *DOS* en el |JSON|.

.. _json-jackson-date:
.. _json-jackson-localdate:

**Fechas**
  Tanto si se usa el antiguo :java-util:`Date <Date>` como el moderno
  :java-time:`LocalDate`, no es necesario definir ningúna traducción si se
  pretenden trasladar a cadenas según el `estándar ISO-8601
  <https://es.wikipedia.org/wiki/ISO_8601>`_, es decir, si se escriben en el
  |JSON| de la forma ``yyyy-MM-dd``\ [#]_.

  Si la forma de la cadena es otra (p.ej. ``dd/MM/yyyy``) aún es posible de
  manera sencilla indicárselo a la librería mediante una anotación:

  .. code-block:: java

     @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "dd/MM/yyyy")
     private LocalDate fechaNacimiento;

  .. code-block:: java

     @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "dd/MM/yyyy", timezone = "Europe/Madrid")
     private Date fechaNacimiento;

  Este último método, no obstante, sólo sirve para especificar la traducción de
  un atributo en concreto. Si se quiere una configuración que afecte a todos los
  atributos que contengan fechas, entonces el modo de obrar difiere entre uno y
  otro tipo:

  :java-util:`Date <Date>`
     Podemos especificar el formato de fecha al crear el *Builder*:

     .. code-block:: java
        :emphasize-lines: 2,3

        MapperBuilder<?, ?> builder = JsonMapper.builder(factory)
           .defaultDateFormat(new SimpleDateFormat("dd/MM/yyyy"))
           .defaultTimeZone(TimeZone.getTimeZone("Europe/Madrid"));  // o TimeZone.getDefault()

     Como se ve también es conveniente especificar la zona horaria.

  :java-time:`LocalDate <LocalDate>`
     La configuración difiere porque hay que hacerla definiendo un módulo:

     .. code-block:: java
        :emphasize-lines: 8

        DateTimeFormatter pattern = DateTimeFormatter.ofPattern("dd/MM/yyyy");

        SimpleModule module = new SimpleModule();  
        module.addSerializer(LocalDate.class, new LocalDateSerializer(pattern))
        module.addDeserializer(LocalDate.class, new LocalDateDeserializer(pattern));

         MapperBuilder<?, ?> builder = JsonMapper.builder(factory)
            .addModule(module);
     
Traductor específico
--------------------
La librería incluye un mecanismo para hacer traducciones totalmente arbitrarias
de cualquier tipo que se nos pueda ocurrir.  Ilustrémoslo con la serialización y
deserialización artesanal de una tipo |LocalDate|, aunque ya esté resuelto
en la propia librería. Sin embargo, nos sirve para ilustrarlo:

.. code-block:: java
   :emphasize-lines: 3, 11, 21

   public class Traductor {
       
       public static DateTimeFormatter df = DateTimeFormatter.ofPattern("yyyy-MM-dd");

       public static class DateSerializer extends JsonSerializer<LocalDate> {

           @Override
           public void serialize(LocalDate value, JsonGenerator gen, SerializerProvider sp) 
               throws IOException, JsonProcessingException {
                   if(value == null) gen.writeNull();
                   else gen.writeString(df.format(value));     // LocalDate --> String
           }
       }

       public static class DateDeserializer extends JsonDeserializer<Date> {

           @Override
           public Date deserialize(JsonParser parser, DeserializationContext context)
               throws IOException, JsonProcessingException {
                   try {
                      return LocalDate.parse(parser.getText(), df);  // String --> LocalDate
                   }
                   catch(ParseException err) {
                      throw new RuntimeException(err);
                   }
           } 
       }
   }

En definitiva, al serializar tenemos que indicar cómo pasar del tipo a una
cadena (que será la que se escriba en el |JSON|), y al deserializar cómo pasar
de la cadena que aparece en el |JSON| al tipo de Java correspondiente.

Y ya sólo quedaría indicar el campo en que se va a usar este traductor:

.. code-block:: java

   @JsonSerialize(using=Traductor.DateSerializer.class)
   @JsonDeserialize(using=Traductor.DateDeserializer.class)
   private Date nacimiento;

Y en caso de que hubiera varios atributos :java-time:`LocalDate <LocalDate>` en
las clases implicadas y todas se quieran traducir igual, podríamos ahorrarnos la
anotación individual en cada uno de los atributos y hacer lo siguiente:

.. code-block:: java

   SimpleModule module = new SimpleModule();

   module.addSerializer(java.util.Date.class, new Traductor.DateSerializer());
   module.addDeserializer(java.util.Date.class, new Traductor.DateDeserializer());
   
   
  MapperBuilder<?, ?> builder = JsonMapper.builder(factory)
   .addModule(module);

.. tip:: Obsérvese que el segundo mecanismo para :ref:`convertir fechas
   LocalDate <json-jackson-localdate>` es equivalente a este que indicamos
   ahora. Simplemente ya están definidas las clases serializadoras y
   deserializadoras para los tipos incluidos en `java.time` y nos limitamos a
   usarlas en vez de definirlas nosotros.

.. rubric:: Notas al pie

.. [#] Siempre que el tipo, claro está, sea un primitivo de |JSON| (p. ej. una
   cadena). Si no lo es entonces habrá que definir cómo realizar la traducción,
   cosa que expondremos en :ref:`json-jackson-no-primitivos`.

.. [#] En realidad, si en vez de una cadena, el |JSON| presenta un número,
   entonces la librería entenderá que el tiempo se ha definido e `tiempo
   UNIX <https://es.wikipedia.org/wiki/Tiempo_Unix>`_. La escritura siempre será
   en forma de cadena, a menos que se use :jackson-databind:`DateTimeFeature
   <cfg/DateTimeFeature>` para cambiar el comportamiento:

   .. code-block:: java
      :emphasize-lines: 2

      MapperBuilder<?, ?> builder = JsonMapper.builder(factory)
         .enable(DateTimeFeature.WRITE_DATES_AS_TIMESTAMPS);

.. |JSON| replace:: :abbr:`JSON (JavaScript Object Notation)`
.. |Date| replace:: :java-util:`Date <Date>`
.. |LocalDate| replace:: :java-time:`LocalDate <LocalDate>`
.. |XML| replace:: :abbr:`XML (eXtensible Markup Language)`
.. |YAML| replace:: :abbr:`YAML (YAML Ain't Markup Language)`

.. |JsonMapper| replace:: :jackson-databind:`JsonMapper <json/JsonMapper>`
.. |JsonFactory| replace:: :jackson-core:`JsonFactory <json/JsonFactory>`
.. |JsonMapper.Builder| replace:: :jackson-databind:`JsonMapper.Builder <json/JsonMapper.Builder>`
.. |JsonReadFeature| replace:: :jackson-core:`JsonReadFeature <json/JsonReadFeature>`
.. |JsonWriteFeature| replace:: :jackson-core:`JsonWriteFeature <json/JsonWriteFeature>`
.. |SerializationFeature| replace:: :jackson-databind:`SerializationFeature`
.. |DeserializationFeature| replace:: :jackson-databind:`DeserializationFeature`
.. |MapperBuilder| replace:: :jackson-databind:`MapperBuilder <cfg/MapperBuilder>`
.. |ObjectMapper| replace:: :jackson-databind:`ObjectMapper`
