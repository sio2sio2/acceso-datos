final String protocol = "jdbc:sqlite:";

String dbUrl = String.format("%s%s", dbProtocol, ":memory:");  // Base de datos en la memoria

try (
   Connection conn = DriverManager.getConnection(url);
   Statement stmt = conn.createStatement();
) {

   // Particular de SQLite: respetar la integredad referencial (opcional).
   stmt.execute("PRAGMA foreign_keys = ON");

   // Tabla Departamento.
   stmt.executeUpdate("""
      CREATE TABLE Departamento (
         id_departamento   INTEGER PRIMARY KEY /* GENERATED BY DEFAULT AS IDENTITY */,
         denominacion      VARCHAR(50)    NOT NULL
      );
   """);

   // Tabla Centro
   stmt.executeUpdate("""
      CREATE TABLE Centro (
         id_centro         INTEGER        PRIMARY KEY /* GENERATED BY DEFAULT AS IDENTITY */,
         nombre            VARCHAR(100)   NOT NULL
      );
   """);

   // Tabla Profesor.
   stmt.executeUpdate("""
      CREATE TABLE Profesor (
         id_profesor       INTEGER        PRIMARY KEY /* GENERATED BY DEFAULT AS IDENTITY */,
         apelativo         VARCHAR(50)    NOT NULL,
         nombre            VARCHAR(75)    NOT NULL,
         apellidos         VARCHAR(150)   NOT NULL,
         sustituye         INTEGER        UNIQUE DEFAULT NULL,

         CONSTRAINT fk_pro_pro FOREIGN KEY(sustituye) REFERENCES Profesor(id_profesor)
            ON DELETE SET NULL
            ON UPDATE CASCADE
      );
   """);

   // Relación Profesor-Centro.
   stmt.executaUpdate("""
      CREATE TABLE Trabaja (
         profesor          INTEGER,
         centro            INTEGER,
         departamento      INTEGER,
         -- Para permitir que un mismo profesor tenga varios casilleros.
         casillero         INTEGER ARRAY    NOT NULL,
         
         CONSTRAINT pk_tra     PRIMARY KEY(profesor, centro),
         CONSTRAINT fk_tra_pro FOREIGN KEY(profesor) REFERENCES Profesor(id_profesor)
            ON DELETE CASCADE
            ON UPDATE CASCADE,
         CONSTRAINT fk_tra_cla FOREIGN KEY(centro) REFERENCES Centro(id_centro)
            ON DELETE CASCADE
            ON UPDATE CASCADE,
         CONSTRAINT fk_est_dep FOREIGN KEY("departamento") REFERENCES Departamento(id_departamento)
            ON DELETE SET NULL
            ON UPDATE CASCADE
      );
   """);

   // Trigger para evitar que un sustituto pueda aparecer en Trabaja,
   // ya que su trabajo debe ser el del titular. ESTO NO ES ESTÁNDAR.

   stmt.executeUpdate("""
      CREATE TRIGGER NoSustitutoEnTrabaja
      BEFORE INSERT ON Trabaja
      FOR EACH ROW
      WHEN (SELECT sustituye FROM Profesor WHERE id_profesor = NEW.profesor) IS NOT NULL
      BEGIN
         SELECT RAISE(FAIL, 'Imposible registrar un sustituto en Trabaja: hace la misma labor que el sustituido.');
      END;
   """);

   // Más sentencias que ya veremos.
}
catch(SQLException err) {
   err.printStackTrace();
   System.exit(1);
}
