.. _manipulacion-archivos:

Consulta y manipulación de contenidos
*************************************
Para acceder a los contenidos de los archivos, antes tenemos que tener claro con
qué tipos de información almacenada podemos encontrarnos. Básicamente, podemos
clasificarla en estos tipos:

#. Información accesible a través de un |SGBD| (o sea, una base de datos), que
   es el modo en que debe almacenarse la información cuando es abundante y
   necesitamos acceder a ella de forma eficiente. Gran parte del curso tratará
   de ella, así que, por ahora, no profundizaremos más.

#. Información en archivos, que pueden ser de distinto tipo:

   a. Archivos de **texto**:

      * Sin formato específico, con lo que no tendremos una biblioteca
        especializada que nos permita rescatar la información, y deberemos
        acceder a ella a través de los métodos genéricos de lectura de archivos.

      * Con formato específico, para el cual sí dispondremos de biblioteca
        especializada. Formatos típicos  son |CSV|, |INI|, |JSON|, |YAML| o
        |XML|. Dejaremos el acceso a algunos de estos formatos para la próxima
        unidad.

   #. Archivos **binarios**, esto es, ilegibles directamente por un humano y
      que requieren forzosamente de algún método para su acceso. Entre ellos
      cabe destacar:

      * Los producidos por la **serialización** directa de objetos.
      * Los que responde a un formato específico para el cual, como en el caso
        de archivos de texto, necesitaremos una biblioteca especializada para su
        tratamiento.

Nuestro plan de estudios será el siguiente:

a. Dedicaremos el resto de la unidad a ver cómo acceder a archivos de texto sin
   formato y binarios generados por *serialización*.

#. En la siguiente unidad trataremos algunos formatos típicos de archivos de
   texto. No lo haremos lo propio con formatos de archivos binarios.

#. El resto de las unidades se dedicarán al acceso a bases de datos de distinto
   tipo con distintas técnicas.

Archivos de texto
=================
En este tipo de archivos el acceso es :dfn:`secuencial`, de manera que no hay
modo de acceder a una parte concreta de la información: simplemente se abre el
archivo y se genera un flujo. Para su manipulación (tanto lectura como
escritura) basta con utilizar algunos de los métodos del ya mencionado
:java-nio:`Files <Files>`:

Lectura
-------
Hay varios métodos que pueden ayudarnos a leer un archivo, pero nos decantamos
por:

.. code-block:: java

   Path archivo = Path.of(System.getProperty("user.home"), ".bashrc");
   InputStream st = Files.newInputStream(archivo); // Si no puede abrirse, puede generar un error.

ya que genera un objeto ``InputStream``, que es el mismo que se obtiene al
extraer contenido de una |URL| mediante este código:

.. code-block:: java

   URL url = new URI("https://etc...").toURL();
   InputStream st = url.openStream();

y que también coincide con el tipo de ``System.in``:

.. code-block:: java

   InputStream st = System.in;

En consecuencia, a partir de este punto podemos tratar estas tres entradas
diferentes de un mismo modo (p.e. usando la clase :java-util:`Scanner
<Scanner>`). Si el archivo lo vamos a manejar por líneas lo más adecuado es
hacer lo siguiente:

.. code-block:: java

   InputStreamReader sr =  new InputStreamReader(st);
   BufferedReader br = new BufferedReader(sr);

y ya este objeto tratarlo como prefiramos:

.. code-block:: java

   String line;
   while((line = br.readLine()) != null) {
      // Tratamiento de cada línea.
   }

o bien:

.. code-block:: java

   br.lines().forEach(line -> {
      // Tratamiento de cada línea.
   });

o incluso:

.. code-block:: java

   for(String line: br.lines().toList()) {
      // Tratamiento de cada línea.
   }

Finalmente, habría que cerrar el flujo:

.. code-block:: java

   br.close();  // El resto se cierra en cascada.

.. note:: El método ``lines()`` devuelve un flujo por líneas (``Stream<String>``)
   al que se puede aplicar :ref:`estrategias de programación funcional
   <java-stream>`.

Poniendo todo junto y usando `try para el tratamiento de errores y el autocierre
<https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html>`_:

.. code-block:: java

   Path archivo = Path.of(System.getProperty("user.home"), ".bashrc");
   try (
      InputStream st = Files.newInputStream(archivo);
      BufferedReader br = new BufferedReader(new InputStreamReader(st))
   ) {
      for(String line: br.lines().toList()) {
         // Tratamiento de cada línea.
      }
   }
   catch (Exception err) {
      err.printStackTrace();
   }

Escritura
---------
En este tipo de archivos, obviamente, tenemos que escribir texto, o sea,
cadenas, pero no directamente caracteres, sino bytes. Por lo demás, basta con
utilizar otro método de :java-nio:`Files <Files>` para abrir un flujo de salida:

.. code-block:: java

   String contenido = "Este es el texto del archivo";

   Path archivo = Path.of(System.getProperty("java.io.tmpdir"), "caca.txt");

   try (OutputStream st = Files.newOutputStream(archivo)) {
      st.write(contenido.getBytes());
   }
   catch (IOException err) {
      err.printStackTrace();
   }

En este caso, se ha abierto el archivo para incluir en él la información
suministrada sin respetar la que ya pudiera haber. Sin embargo, pueden añadirse
a ``Files.newOutputStream`` argumentos adicionales para incluir una o varias
opciones que modifiquen este comportamiento (véase
:java-nio:`StandardOpenOption <StandardOpenOption>`). Por ejemplo:

.. code-block:: java

   // Se añade contenido, por lo que se respeta el que pudiera haber.
   OutputStream st = Files.newOutputStream(archivo, StandardOpenOption.APPEND);

Serialización de objetos
========================
El otro mecanismo de acceso a archivos es el :dfn:`aleatorio`, implementado
mediante la clase :java-io:`RandomAccessFile` y gracias al cual se puede acceder
a bytes concretos y avanzar o retroceder dentro de él, tanto para leer como para
escribir.

Este mecanismo nos permite escribir distintos tipos de datos e incluso objetos
completos, pero es tedioso (véase `almacenar objetos en archivos de acceso
aleatorio
<`https://www.clasesdeinformaticaweb.com/java-desde-cero/randomaccessfile-en-java-archivos-de-acceso-aleatorio/>`_).

En vez de ello, sale más a cuenta *serializar* objetos y almacenarlos en disco
para poderlos rescatar posteriormente. Eso sí, antes debemos definir el
concepto. La :dfn:`serialización` es el proceso de convertir datos en una
secuencia de *bytes*, cuya lectura permite posteriormente recuperar los datos
originales. Como los archivos son precisamente eso mismo, secuencias de *bytes*,
es un mecanismo apropiado para almacenar datos en disco.

Antes de dar un ejemplo, no obstante, en preciso establecer varias premisas:

* En cada archivo sólo podemos serializar un objeto, por lo que si queremos
  serializar varios tendremos que incluirlos dentro de una lista o una
  estructura parecida.

* Para que un objeto sea serializable debe implementar la interfaz
  :java-io:`Serializable`.

* Escribimos y leemos el archivo de una tacada. Esto es un problema si la
  cantidad de datos es grande, pero en ese caso, deberíamos haber usado una base
  de datos.

Para ilustrar cómo se serializan objetos definamos un clase muy simple:

.. code-block:: java
   :emphasize-lines: 1

   public class Persona implements Serializable {
       
       private String nombre;
       private int edad;

       Persona(String nombre, int edad) {
           this.nombre = nombre;
           this.edad = edad;
       }

       public String getNombre() {
           return nombre;
       }

       public int getEdad() {
           return edad;
       }

       @Override
       public String toString() {
           return String.format("%s, %d", nombre, edad);
       }
   }

Escritura
---------
Para escribir en disco varios objetos "*Persona*", podemos hacer lo siguiente:

.. code-block:: java

   // Las listas ya son serializables.
   List<Persona> personas = List.of(
      new Persona("Manolo", 15),
      new Persona("Pablo", 10)
   );

   Path ruta = Path.of(System.getProperty("java.io.tmpdir"), "caca.bin");
   try (ObjectOutputStream st = new ObjectOutputStream(Files.newOutputStream(ruta))) {
      st.writeObject(o);
   }

Y listo, tendremos en :file:`caca.bin` la lista de personas serializadas. 

Lectura
-------
Para recuperar un objeto serializado, hay que hacer el proceso inverso:

.. code-block:: java

   try (ObjectInputStream st = new ObjectInputStream(Files.newInputStream(ruta))) {
      Object o = st.readObject();

      // Ahora podemos usar "o" como prefiramos:
      ((List<Persona>) o).forEach(System.out::println);
   }
   catch (Exception err) {
      err.printStackTrace();
   }


.. Enlaces:
   https://www.arquitecturajava.com/java-stream-file-y-manejo-de-ficheros/
   https://stackoverflow.com/questions/4308554/simplest-way-to-read-json-from-a-url-in-java
   https://stackoverflow.com/questions/28977308/read-all-lines-with-bufferedreader

   https://www.javadoc.io/doc/com.google.code.gson/gson/latest/com.google.gson/com/google/gson/package-summary.html
   https://jarroba.com/gson-json-java-ejemplos/

.. |SGBD| replace:: :abbr:`SGBD (Sistemas Gestores de Bases de Datos)`
.. |CSV| replace:: :abbr:`CSV (Comma-Separated Values)`
.. |INI| replace:: :abbr:`INI (INItialization file)`
.. |JSON| replace:: :abbr:`JSON (JavaScript Object Notation)`
.. |YAML| replace:: :abbr:`YAML (YAML Ain't Markup Language)`
.. |XML| replace:: :abbr:`XML (eXtensible Markup Language)`
.. |URL| replace:: :abbr:`URL (Uniform Resource Locator)`
