.. _json-jackson:

Jackson
*******
Otra librería muy utilizada y que tiene la ventaja de que también soporta
:ref:`XML <xml>` es la proporcionada por el `proyecto Jackson
<https://github.com/FasterXML/jackson>`_.

Como :ref:`GSON <json-gson>`, nos permite hacer una conversión automática entre
el modelo de objetos y |JSON| para lo cual podemos definir las clases para
:ref:`Tutor <class-tutor>`, |Alumno| y :ref:`Grupo <class-grupo>` exactamente de
:ref:`la misma forma <gson-auto>`. En este caso, la librería que necesitamos es
`jackson-databind
<https://mvnrepository.com/artifact/tools.jackson.core/jackson-databind>`_.

.. _json-jackson-basico:

Operativa básica
================
Empecemos por ver cómo leer o escribir :ref:`el archivo JSON de referencia
<grupos.json>`.

.. _json-jackson-read:

Lectura
-------
El código es muy similar al practicado con `GSON`:

.. code-block:: java
   :emphasize-lines: 2, 5

   Path ruta = Path.of(System.getProperty("user.home"), "grupos.json");
   ObjectMapper mapper = new JsonMapper();

   try(InputStream st = Files.newInputStream(ruta)) {
       Grupo[] grupos = mapper.readValue(st, Grupo[].class);
       Arrays.stream(grupos).forEach(System.out::println);
   }
   catch(IOException err) {
       err.printStackTrace();
   }

Si, en cambio, quisiéramos generar una lista de grupos y no un array:

.. code-block:: java

   TypeReference<List<Grupo>> GrupoLista =  new TypeReference<>(){};
   List<Grupo> grupos = mapper.readValue(sr, GrupoLista);

.. note:: Cuando los atributos de clases incluidas en la traducción
   son secuencias, es indiferente que sea listas o array: la traducción
   se lleva a cabo de igual forma. En nuestro ejemplo, es el caso del atributo
   ``miembros`` de :ref:`Grupo <class-grupo>`, que lo hemos definido como un
   *array*, pero podría perfectamente ser una lista.

.. _json-jackson-write:

Escritura
---------
Por su parte la escritura a un |JSON| desde un modelo de objetos tampoco tiene
excesivas diferencias respecto a lo que encontraríamos en `GSON`:

.. code-block:: java
   :emphasize-lines: 27, 30

   public static void main(String[] args) {

       Grupo[] grupos = {
           new Grupo(
               (short) 1,
               "ESO",
               'B',
               new Tutor("Pepe M.J.", "Matemáticas"),
               new Alumno[] {
                  new Alumno("Pablito", LocalDate.of(2008, 10, 2)),
                  new Alumno("Juanito", LocalDate.of(2010, 3, 25))
               }
           ),
           new Grupo(
               (short) 2,
               "ESO",
               'C',
               new Tutor("Pedro J.M.", "Lengua"),
               new Alumno[] {
                  new Alumno("Lola", LocalDate.of(2009, 1, 11)),
                  new Alumno("Manolito", LocalDate.of(2010, 5, 15))
               }
           )
       };

       Path ruta = Path.of(System.getProperty("java.io.tmpdir"), "grupos.json");
       ObjectMapper mapper = new JsonMapper();

       try (OutputStream st = Files.newOutputStream(ruta)) {
           mapper.writeValue(st, grupos);
       }
       catch (IOException err) {
           err.printStackTrace();
       }
   }

Al escribir, es indiferente si usamos arrays o listas.

.. note:: Existe el método ``writeValueAsString`` que devuelve una cadena con el
   |JSON| resultante:

   .. code-block:: java

      String contenido = mapper.writeValueAsString(grupos);

.. _json-jackson-conf:

Configuración del mapeo
=======================
Bajo el epígrafe anterior hemos hecho una traducción muy sencilla en la que no
hemos definido ninguna característica particular para la lectura o la escritura
del |JSON| ni hemos necesitado afinar la traducción de los atributos del objeto:
se llaman igual en Java y en |JSON|, no hemos necesitado evitar ninguno, todos
son traducibles directamente a algún tipo existente en el formato |JSON|.

Lo habitual en cambio es que necesitemos configurar el mapeo y eso es lo que
veremos ahora.

Creación del mapper
-------------------
Cuando queremos configurar las características del mapeo, no debemos crear el
*mapper* directamente como hicimos anteriormente:

.. code-block:: java

   ObjectMapper mapper = new JsonMapper();  // Inmutable, no se puede configurar.

ya que a partir de la versión 3 de *Jackson* `los objetos de mapeos son
inmutables
<https://cowtowncoder.medium.com/jackson-3-0-immutability-w-builders-d9c532860d88>`_
y no pueden configurarse después de haberse creado.

El proceso completo de creación de un mapeo tiene tres fases:

1. Creación de un *Factory* (|JsonFactory|), en
   la que podemos ajustar características de serialización
   (|JsonWriteFeature|) y deserialización
   (|JsonReadFeature|) propias del formato (|JSON| en este caso).
2. Creación de un *Builder* (|JsonMapper.Builder|), en la que podremos añadir
   módulos (los veremos más adelante), características generales de serialización
   (|SerializationFeature|) y deserialización (|DeserializationFeature|), y
   complementar la definición las clases del modelo con la técnica del *MixIn*.
3. Creación del *Mapper* propiamente (|JsonMapper|).

Ilustrémoslo:

.. code-block:: java

   JsonFactory factory = JsonFactory.builder()
        .enable(JsonReadFeature.ALLOW_JAVA_COMMENTS)  // Características particulares de de/serialización
        .build();

   // MapperBuilder<?, ?> o JsonMapper.Builder, que es la clase padre.
   MapperBuilder<?, ?> builder = JsonMapper.builder(factory)
        .enable(SerializationFeature.INDENT_OUTPUT)  // Características generales de de/serialización
        .addModule(module)      // Supongamos que hemos definido ese modulo. Ya se tratará más adelante
        .addMixIn(Grupo.class, GrupoMixin.class);   // Mezclamos (ya veremos la utilidad)

    // ObjectMapper o JsonMapper, que es la clase padre.
    ObjectMapper mapper = builder.build();

.. note:: |MapperBuilder| y |ObjectMapper| son clases padre que se comparten con
   otros formatos como |YAML| o |XML|. Si nuestra intención es soportar varios
   formatos, es probable que nos convenga definir ``builder`` y ``mapper`` como
   de estas clases respectivamente en vez de las clases más concretas
   |JsonMapper.Builder| y |JsonMapper|.

Estás tres etapas pueden simplificarse si necesitamos menos configuración. Ya hemos
visto que pueden reducirse a una, si no necesitamos configuración adicional en
absoluto:

.. code-block:: java

   ObjectMapper mapper = new JsonMapper();

O a dos, si no necesitamos añadir características particulares de serialización
o deserialización:

.. code-block:: java
   :emphasize-lines: 1

   MapperBuilder<?, ?> builder = JsonMapper.builder() // No hemos definido factory.
        .enable(SerializationFeature.INDENT_OUTPUT)
        .addModule(module)
        .addMixIn(Grupo.class, GrupoMixin.class);

   ObjectMapper mapper = builder.build();

.. _json-jackson-annotations:

Anotaciones
-----------
Hemos visto muy por encima cómo trasladar objetos a |JSON| y viceversa. La regla
es que cada atributo del objeto se traduce en una propiedad |JSON| con el mismo
nombre y que conserva el mismo valor\ [#]_. Centrémonos en |Alumno|:

.. code-block:: java

   public class Alumno implements Serializable {

       // Atributos
       private String nombre;
       private LocalDate fechaNacimiento;

       // Resto de la implementación
   }

La serialización de un objeto ``Grupo`` será esta:

.. code-block:: json

   {
      "nombre": "Matías Sánchez Aguado",
      "fechaNacimiento": "2010-05-15"
   }

Ahora bien, ¿cómo puede personalizarse la serialización para cambiar el nombre
de un atributo o no serializarlo? La librería para ello utiliza `anotaciones
<https://www.geeksforgeeks.org/java/annotations-in-java/>`_ que permiten indicar
todos estos particulares:

.. code-block:: java
   :emphasize-lines: 6, 11

   public class Alumno implements Serializable {

       // Atributos
       private String nombre;

       @JsonProperty("nacimiento")
       private LocalDate fechaNacimiento;

       // ...

       @JsonIgnore
       public int getEdad() {
          return Period.between(fechaNacimiento, LocalDate.now()).getYears();
       }
      
   }

De esta forma logramos que en el |JSON| la propiedad no sea
``fechaNacimiento``, sino ``nacimiento``. Además, el método que nos devuelve la
edad tiene forma de *getter* por lo que *Jackson* lo entenderá como tal y
escribirá en el |JSON| la propiedad *edad*, sin que esta exista realmente en el
modelo de datos. Por eso añadimos la anotación ``@JsonIgnore``.

El problema de anotar directamente la clase es que quizás no nos resulte
elegante o directamente no podamos, porque no dependa de nosotros la definición.
Para poder añadir anotaciones sin modificar la clase original, *Jackson*
proporciona un mecanismo: la mezcla. Para ello podríamos definir aparte otra
clase distinta que contenga exclusivamente los atributos que necesitan
anotación:

.. code-block:: java

   public abstract class AlumnoMixin {

      @JsonProperty("nacimiento")
      private LocalDate nacimiento;

      @JsonIgnore
      public abstract int getEdad();
   }

Luego, al definir el mapeo. se declara que deseamos mezclar la clase original
con la clase abstracta anotada:

.. code-block:: java
   :emphasize-lines: 2

   MapperBuilder<?, ?> builder = JsonMapper.builder(factory)
        .addMixIn(Alumno.class, AlumnoMixin.class);

Existen otras anotaciones interesante que introduciremos más adelante.

.. note:: Al :ref:`serializar en formato XML <xml-jackson>` con esta librería,
   las anotaciones se vuelven imprescindibles, porque es la única forma de
   indicar, entre otras cosas, si un atributo de la clase será un elemento o un
   atributo |XML|.

.. _json-jackson-no-primitivos:

Traducción de tipos no primitivos
=================================
En el ejemplo anterior todos los atributos de los objetos de *Java* tienen una
correspondencia con un tipo primitivo de |JSON|: cadenas, números, secuencias
(ya sean ``Array`` o :java-util:`ArrayList <ArrayList>`) excepto uno del que no
nos hemos preocupado, por lo que no hemos defino cómo debe ser su serialización.

Traducciones predefinidas
-------------------------
Tampoco es necesario definir una traducción específica en otros casos en que no
hay correspondencia, pero *Jackson* nos provee una predeterminada:

**Enumeraciones** (:java-lang:`Enum`),
  Si se pretende que la traducción a  |JSON| sean las constantes de enumeración
  convertidas a cadenas. Por ejemplo, en este caso:

  .. code-block:: java
     :name: Etapa-enum

     public enum Etapa {
       INFANTIL,
       PRIMARIA,
       ESO,
       BACHILLERATO,
       FP,
       UNIVERSIDAD;

       /**
        * Devuelve en enum a partir de su ordinal
        */
       public static Etapa indexOf(int ordinal) {
          return Etapa.values()[ordinal];
       }
     }

  los valores se verán como las cadenas *INFANTIL*, *PRIMARIA*, *ESO* en el |JSON|.
  De hecho, podríamos definir el atributo ``etapa`` de :ref:`Grupo <class-grupo>` como
  de tipo ``Etapa`` y todo seguiría funcionado perfectamente.

.. _json-jackson-date:
.. _json-jackson-localdate:

**Fechas**
  Tanto si se usa el antiguo :java-util:`Date <Date>` como el moderno
  :java-time:`LocalDate`, no es necesario definir ningúna traducción si se
  pretenden trasladar a cadenas según el `estándar ISO-8601
  <https://es.wikipedia.org/wiki/ISO_8601>`_, es decir, si se escriben en el
  |JSON| de la forma ``yyyy-MM-dd``\ [#]_\ [#]_.

  Si la forma de la cadena es otra (p.ej. ``dd/MM/yyyy``) aún es posible de
  manera sencilla indicárselo a la librería mediante una anotación. Imaginemos
  que en vez de almacenar la edad, almacenamos la fecha de nacimiento del
  alumno:

  .. code-block:: java

     @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "dd/MM/yyyy")
     private LocalDate fechaNacimiento;

     /* ... */

     /**
      * "Atributo" calculado a partir de la fecha de nacimiento.
      * Como le hemos dado la forma de un getter, Jackson lo tomará como
      * tal y al escribir el alumno incluirá la propiedad "edad". Por eso,
      * especificamos que lo salte.
      */
     @JsonIgnore
     public int getEdad() {
        return Period.between(fechaNacimiento, LocalDate.now()).getYears();
     }

  .. code-block:: java

     @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "dd/MM/yyyy", timezone = "Europe/Madrid")
     private Date fechaNacimiento;

  Este último método, no obstante, sólo sirve para especificar la traducción de
  un atributo en concreto. Si se quiere una configuración que afecte a todos los
  atributos que contengan fechas, entonces el modo de obrar difiere entre uno y
  otro tipo:

  :java-util:`Date <Date>`
     Podemos especificar el formato de fecha al crear el *Builder*:

     .. code-block:: java
        :emphasize-lines: 2,3

        MapperBuilder<?, ?> builder = JsonMapper.builder(factory)
           .defaultDateFormat(new SimpleDateFormat("dd/MM/yyyy"))
           .defaultTimeZone(TimeZone.getTimeZone("Europe/Madrid"));  // o TimeZone.getDefault()

     Como se ve también es conveniente especificar la zona horaria.

  :java-time:`LocalDate <LocalDate>`
     La configuración difiere porque hay que hacerla definiendo un módulo:

     .. code-block:: java
        :emphasize-lines: 8

        DateTimeFormatter pattern = DateTimeFormatter.ofPattern("dd/MM/yyyy");

        SimpleModule module = new SimpleModule();  
        module.addSerializer(LocalDate.class, new LocalDateSerializer(pattern))
        module.addDeserializer(LocalDate.class, new LocalDateDeserializer(pattern));

         MapperBuilder<?, ?> builder = JsonMapper.builder(factory)
            .addModule(module);
     
Traductor específico
--------------------
La librería incluye un mecanismo para hacer traducciones totalmente arbitrarias
de cualquier tipo que se nos pueda ocurrir. Ilustrémoslo con la serialización y
deserialización artesanal de una tipo |LocalDate|, aunque ya esté resuelto
en la propia librería. Sin embargo, nos sirve para ilustrarlo:

.. caution:: Lo que exponemos ahora **ya está resuelto** en *Jackson* con
   |LocalDateSerializer| y |LocalDateDeserializer| (como acabamos de ver) por lo
   que no tiene mucho sentido perder el tiempo en reimplementarlo.  Sin embargo,
   es didácticamente pertinente porque nos sirve para ilustrar cómo definir
   serializadores y deserializadores.

.. code-block:: java
   :emphasize-lines: 3, 11, 21

   public class Traductor {
       
       public static DateTimeFormatter df = DateTimeFormatter.ofPattern("yyyy-MM-dd");

       public static class DateSerializer extends JsonSerializer<LocalDate> {

           @Override
           public void serialize(LocalDate value, JsonGenerator gen, SerializerProvider sp) 
               throws IOException, JsonProcessingException {
                   if(value == null) gen.writeNull();
                   else gen.writeString(df.format(value));     // LocalDate --> String
           }
       }

       public static class DateDeserializer extends JsonDeserializer<Date> {

           @Override
           public Date deserialize(JsonParser parser, DeserializationContext context)
               throws IOException, JsonProcessingException {
                   try {
                      return LocalDate.parse(parser.getText(), df);  // String --> LocalDate
                   }
                   catch(ParseException err) {
                      throw new RuntimeException(err);
                   }
           } 
       }
   }

En definitiva, al serializar tenemos que indicar cómo pasar del tipo a una
cadena (que será la que se escriba en el |JSON|), y al deserializar cómo pasar
de la cadena que aparece en el |JSON| al tipo de Java correspondiente.

Y ya sólo quedaría indicar el campo en que se va a usar este traductor:

.. code-block:: java

   @JsonSerialize(using=Traductor.DateSerializer.class)
   @JsonDeserialize(using=Traductor.DateDeserializer.class)
   private Date nacimiento;

Y en caso de que hubiera varios atributos :java-time:`LocalDate <LocalDate>` en
las clases implicadas y todas se quieran traducir igual, podríamos ahorrarnos la
anotación individual en cada uno de los atributos y hacer lo siguiente:

.. code-block:: java

   SimpleModule module = new SimpleModule();

   module.addSerializer(java.util.Date.class, new Traductor.DateSerializer());
   module.addDeserializer(java.util.Date.class, new Traductor.DateDeserializer());
   
   
  MapperBuilder<?, ?> builder = JsonMapper.builder(factory)
   .addModule(module);

.. tip:: Obsérvese que el mecanismo específico para definir el :ref:`formato de
   las fechas LocalDate <json-jackson-localdate>` es equivalente a este que
   indicamos ahora. Simplemente las clases serializadora (|LocalDateSerializer|)
   y deserializadora (|LocalDateDeserializer|) ya están definidas y nos
   limitamos a usarlas en vez de definirlas nosotros.

.. rubric:: Notas al pie

.. [#] Siempre que el tipo, claro está, sea un primitivo de |JSON| (p. ej. una
   cadena). Si no lo es entonces habrá que definir cómo realizar la traducción,
   cosa que expondremos en :ref:`json-jackson-no-primitivos`.

.. [#] De hecho, es de este tipo la única excepción que incluimos en nuestro
   ejemplo: hay un dato de tipo :java-time:`LocalDate <LocalDate>`, pero como su
   representación a cadena fue la estándar no nos preocupamos de su
   serialización.

.. [#] En realidad, si en vez de una cadena, el |JSON| presenta un número,
   entonces la librería entenderá que el tiempo se ha definido en `tiempo
   UNIX <https://es.wikipedia.org/wiki/Tiempo_Unix>`_. La escritura siempre será
   en forma de cadena, a menos que se use :jackson-databind:`DateTimeFeature
   <cfg/DateTimeFeature>` para cambiar el comportamiento:

   .. code-block:: java
      :emphasize-lines: 2

      MapperBuilder<?, ?> builder = JsonMapper.builder(factory)
         .enable(DateTimeFeature.WRITE_DATES_AS_TIMESTAMPS);

   De hecho, la traducción a tiempo *UNIX* era el comportamiento predeterminado
   en *Jackson 2*.

.. |JSON| replace:: :abbr:`JSON (JavaScript Object Notation)`
.. |Date| replace:: :java-util:`Date <Date>`
.. |LocalDate| replace:: :java-time:`LocalDate <LocalDate>`
.. |XML| replace:: :abbr:`XML (eXtensible Markup Language)`
.. |YAML| replace:: :abbr:`YAML (YAML Ain't Markup Language)`

.. |JsonMapper| replace:: :jackson-databind:`JsonMapper <json/JsonMapper>`
.. |JsonFactory| replace:: :jackson-core:`JsonFactory <json/JsonFactory>`
.. |JsonMapper.Builder| replace:: :jackson-databind:`JsonMapper.Builder <json/JsonMapper.Builder>`
.. |JsonReadFeature| replace:: :jackson-core:`JsonReadFeature <json/JsonReadFeature>`
.. |JsonWriteFeature| replace:: :jackson-core:`JsonWriteFeature <json/JsonWriteFeature>`
.. |SerializationFeature| replace:: :jackson-databind:`SerializationFeature`
.. |DeserializationFeature| replace:: :jackson-databind:`DeserializationFeature`
.. |MapperBuilder| replace:: :jackson-databind:`MapperBuilder <cfg/MapperBuilder>`
.. |ObjectMapper| replace:: :jackson-databind:`ObjectMapper`
.. |Alumno| replace:: :ref:`Alumno <class-alumno>`
.. |LocalDateSerializer| replace:: :jackson-databind:`LocalDateSerializer <ext/javatime/ser/LocalDateSerializer>`
.. |LocalDateDeserializer| replace:: :jackson-databind:`LocalDateDeserializer <ext/javatime/deser/LocalDateDeserializer>`

