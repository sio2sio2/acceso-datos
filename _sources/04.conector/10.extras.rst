.. _conn-extra:

Extras
******
Arrinconamos bajo este epígrafe algunos aspectos adicionales de los conectores:

Metadatos
=========
.. todo:: DatabaseMetaData y ResultSetMetaData.

.. hint:: Aunque a partir de ahora se enlaza código con algunas propuestas,
   todas ellas están incluidas en un `repositorio de
   Github llamado sqlutils <https://github.com/sio2sio2/sqlutils>`_ listo para
   su uso:

   .. code-block:: xml

      <!-- En pom.xml -->
      <repositories>
           <repository>
               <id>jitpack.io</id>
               <url>https://jitpack.io</url>
           </repository>
       </repositories>

      <dependencies>
        <dependency>
            <groupId>com.github.sio2sio2</groupId>
            <artifactId>sqlutils</artifactId>
            <version>3.1.2</version>
        </dependency>
      </dependencies>

   Es más recomendable usar esta librería auxiliar que bajar el código y
   añadirlo a nuestro proyecto.

.. conn-custom-exceptions:

Excepciones personalizadas
==========================
Es conveniente crear nuestras propias excepciones personalizadas para envolver
las excepciones que pueda generar el acceso a datos. Por ejemplo, para
excepciones no protegidas:

.. literalinclude:: files/DataAccessRuntimeException.java
   :language: java
   :name: DataAccessRuntimeException
   :class: toggle
   :caption: DataAccessRuntimeException.java (:download:`descarga <files/DataAccessRuntimeException.java>`)
   :start-at: public class

Y escribir otra excepcion protegida que llamada ``DataAccessException`` que
derive de |Exception|.

.. _conn-sqlutils:

Tratamiento funcional de las consultas
======================================

.. todo:: Revisar este apartado para utilizar ConnectionWrapper en vez de
   |Connection|.

|ResultSet| permite ir obteniendo fila a fila los resultados de una consulta.
Sin embargo, no proporciona una interfaz funcional que nos permita utilizar las
:ref:`operaciones funcionales habituales <java-stream-operaciones>`. Para
paliarlo podemos definir una clase que haga la conversión (véase el
:download:`codigo fuente <files/SqlUtils.java>`):

.. literalinclude:: files/SqlUtils.java
   :language: java
   :class: toggle
   :name: clase-sqlutils
   :caption: SqlUtils.java (:download:`descarga <files/DataAccessRuntimeException.java>`)
   :start-at: public class

Con estas clases y definiendo un método estático para convertir un registro de
la tabla *Centro* (esto es, un |ResultSet|) en un objeto ``Centro``:

.. code-block:: java

   public static Centro resultSetToCentro(ResultSet rs) throws SQLException {
      int id = rs.getInt("id");
      String nombre = rs.getString("nombre");
      Titularidad titularidad = Titularidad.fromString(rs.getString("titularidad"));
      return new Centro(id, nombre, titularidad);
   }

se puede obtener un objeto :java-util:`Stream <stream/Stream>` que permita recorrer los
resultados de la consulta:

.. code-block:: java
   :emphasize-lines: 6

   // No los cerramos, porque se encargara el cierre del flujo de hacerlo.
   Statement stmt = conn.createStatement();
   ResultSet rs = stmt.executeQuery("SELECT * FROM Centro");
 
   // try-with-resources para asegurarnos de liberar los recursos (stmt y rs)
   try (Stream<Centro> centros = SqlUtils.resultSetToStream(stmt, rs, Main::resultToCentro)) {
      // Tratamos el flujo como estimemos más oportuno.
      for(Centro c: (Iterable<Centro>) centros::iterator) {
         System.out.println(c);
      }
   }

.. warning:: El método es de ejecución perezosa, esto es, genera objetos a
   medida que se consumen. Esto implica que, mientras necesitemos obtener
   elementos del flujo, tanto el objeto de consulta como el de conexión deben
   permanecer abiertos, pues de no ser así, se cerrará también automáticamente
   el objeto |ResultSet| y dejaremos de obtener filas. Por tanto:

   .. code-block:: java

      Stream<Centro> centros = null;

      try(
         Statement stmt = conn.createStatement();
         ResultSet rs = stmt.executeQuery("SELECT * FROM Centro");
      ) {
         centros = SqlUtils.resultSetToStream(stmt, rs, Main::resultToCentro);
      }

      for(Centro c: centros) {
         // Jamás obtendremos ningún centro
         // porque el objeto "rs" está cerrado.
      }

   no funciona en absoluto. Es indispensable que no cerremos los objetos
   |Connection|, |Statement| y |ResultSet| para que el ``Stream`` pueda devolver
   objetos. ¿Cuándo entonces se cierran? De eso se encarga el propio flujo al
   cerrarse (véase la implementación). Por ese motivo el primer argumento que se
   pasa al método es la sentencia o la conexión, dependiendo de lo que más nos
   interese cerrar al terminar de consumir el flujo. Eso sí, debemos asegurarnos
   de cerrar el flujo al acabar con él, razón por la cual en el ejemplo
   ilustrativo de su uso hemos usado una sentencia *try-with-resources*.

.. tip:: El método ``resultSetToStream`` permite no definir la función que
   transforma la fila (el propio |ResultSet|) en un objeto. En ese caso, se
   obtendrá con cada elemento del flujo la propia fila:

   .. code-block:: java

      try(Stream<ResultSet> result = SqlUtils.resultSetToStream(stmt, rs)) {
         // Tratamos el resultado como un Stream.
      }

Cargar esquema desde archivo
============================
Es muy común que la primera vez que se ejecuta la aplicación, ésta cree la base
de datos y defina el esquema y los datos iniciales necesarios. Lo cómodo es que
las sentencias necesarias se encuentren en un guión |SQL| y el programa las lea
de él, en vez de encontrarse incrustadas en el código.

Sin embargo, |JDBC| no tiene definido un método que nos permita ejecutar un
guión |SQL| completo y que pasemos una cadena larga con todas instrucciones
separadas por comas, no asegura que el |SGBD| las descomponga y ejecute
individualmente\ [#]_. La única forma segura de poder ejecutar sus sentencias
es descomponerlas primero. Para ello podemos optar por dos estrategias:

+ `JSQLParser
  <https://mvnrepository.com/artifact/com.github.jsqlparser/jsqlparser>`_ que es
  capaz de procesar el código |SQL| y, por tanto, reconocer los elementos de que
  se compone.

+ Podemos escribir una solución artesanal, si el guión no es complejo y seguimos
  algunas premisas:

  a. Los ';' que completan sentencias deben encontrarse a final de línea.
  #. No pueden usarse las palabras ``begin`` o ``end`` en comentarios, nombres,
     valores, etc.
  #. No pueden usarse bloques ``IF`` en aquellos |SGBD| que los implementen
     (pero sí usarse el estándar ``CASE``).

El código de los métodos ``splitSQL`` y ``executeSQL`` se encuentra dentro de
:ref:`la clase SqlUtils <clase-sqlutils>` referida anteriormente.

.. _conn-transaction-manager:

Gestor de transacciones
=======================
:ref:`Crear transacciones de forma manual <conn-transactions-create>` es bastante engorroso
por lo que resulta muy útil construirse algún mecanismo más sofisticado cómo para llevarlas
a cabo. Una buena propuesta es ésta:

.. literalinclude:: files/TransactionManager.java
   :language: java
   :class: toggle
   :caption: TransactionManager.java (:download:`descarga <files/TransactionManager.java>`)
   :name: TransactionManager

.. caution:: La clase presupone que hemos definido una excepción protegida de usuario
   ``DataAccessException`` semejante a :ref:`DataAccessRuntimeException
   <DataAccessRuntimeException>`.

Las claves de esta clase son:

- Usa un patrón Singleton ampliado (`Multiton <https://en.wikipedia.org/wiki/Multiton_pattern>`_),
  de manera que se puede acceder a las distintas instancias mediante una clave
  definida al crear cada instancia.
- Automatiza la gestión de transacciones para que el programadador sólo se
  tenga que preocupar de definir una expresión *lambda* que contenga todas las
  operaciones que constituyen la transacción.
- La expresión lambda tiene disponible una conexión para realizar con ella las
  operaciones. La gestión de esta conexión (su creación y su cierre) debe correr
  a cuenta del gestor de transacciones, por lo que está protegida para que el
  programador no la cierre por descuido (su método ``close()`` no tiene ningún
  efecto). Esta magia se logra gracias al uso del `patrón Proxy
  <https://medium.com/@AlexanderObregon/the-proxy-pattern-in-java-and-what-makes-it-flexible-at-runtime-ba5248a4ce01>`_
  que permite interceptar los métodos definidos en una interfaz (y |Connection|
  lo es).

Este gestor de transacciones soporta múltiples hilos y el acceso a múltiples
bases de datos:

.. code-block:: java

   TransactionManager tm = TransactionManager.create("CENTRO", ds); // ds es un DataSource ya creado

   // En cualquier punto del código podemos rescatar el objeto gracias a la clave
   tm = TransactionManager.get("CENTRO");

   // Cómo realizar operaciones en una misma transacción
   tm.transaction(conn -> {
      String sqlString = "UPDATE centro SET titularidad = ? WHERE id = ?";
      try {
         try(PreparedStatement pstmt = conn.preparedStatement(sqlString)) {
            pstmt.setInt(2, 11004866);
            pstmt.setString(1, "PUBLICA");
            pstmt.executeUpdate();
         }

         try(PreparedStatement pstmt = conn.preparedStatement(sqlString)) {
            pstmt.setInt(2, 11004039);
            pstmt.setString(1, "PUBLICA");
            pstmt.executeUpdate();
         }
      } catch(SQLException e) {
         // Generamos una excepción personalizada que escala al código
         // externo a la transacción (o también podríamos mostrar algún
         // mensaje de error y no propagar ninguna excepción).
         throw new DataAccessException("Error al actualizar datos", e);
      }

      conn.close() // ¡¡¡NO DEBE HACERSE!!! pero, si se hace, no tiene efecto.
   });

.. note:: El método también puede capturar el resultado que devuelve la expresión lamda:

   .. code-block:: java

      List<Estudiante> estudiantes = tm.transaction(conn -> obtenerEstudiantes(conn));

.. _conn-pool-extra:

*Pool* de conexiones
====================
Ya tratamos cómo crear un :ref:`pool de conexiones <conn-pool>`. Si queremos
simplificar la creación del pool y abstraernos de qué se usa para crearlo,
podemos envolverlo en una clase como esta:

.. literalinclude:: files/ConnectionPool.java
   :class: toggle
   :caption: ConnectionPool.java (:download:`descarga <files/ConnectionPool.java>`)
   :name: ConnectionPool
   :language: java
   :start-at: public class

La clase sigue el patrón ya ensayado para :ref:`TransactionManager
<conn-transaction-manager>`: un `patrón Multiton`_ que asocia a cada *pool* de
conexiones una clave, por lo que crear un *pool* con HikariCP_ es muy sencillo\ [#]_:

.. code-block:: java
   :emphasize-lines: 2, 10

   // Pool de conexiones de una base SQLite en memoria.
   try(ConnectionPool pool = ConnectionPool.create("BD", "jdbc:sqlite:file::memory:?cache=shared")) {
      DataSource ds = pool.getDataSource();
      try(Connection conn = ds.getConnection()) {
         // Hacemos operaciones con la conexión.
      }
   }

   // Aquí ya no podemos usar el pool "DB" porque lo hemos cerrado.
   ConnectionPool.get("DB");  // ERROR: el pool está cerrado.

La última línea muestra cómo puede recuperarse en cualquier momento el *pool*,
siempre que no se haya cerrado.

El objeto puede utilizarse tal como se ha ilustrado para obtener su |DataSource|
y distintas conexiones |Connection| (que habrá que cerrar convenientemente),
pero también puede usarse en conjunción con :ref:`TransactionManager
<TransactionManager>` y dejar que sea el gestor de transacción el que se
encargue de crear y cerrar la conexión que necesitamos.

:ref:`TransactionManager <TransactionManager>`

.. code-block:: java
   :emphasize-lines: 3, 6

   // Pool de conexiones de una base SQLite en memoria.
   try(ConnectionPool pool = ConnectionPool.create("BD", "jdbc:sqlite:file::memory:?cache=shared")) {
      pool.setTransactionManager(); // Crea el gestor de nombre "BD".

      // Usamos conexiones gestionadas por el gestor
      pool.getTransactionManager().transaction(conn -> {

        // Operaciones que comparten una misma transacción

      });
   }

.. admonition:: Advertencia

   Cuando existe el gestor de transacciones correspondiente, el método
   ``getDataSource()`` genera un mensaje advirtiendo de que es conveniente
   manejar las conexiones a través del gestor, que para eso se ha creado.

.. note:: En realidad, los métodos ``setTransactionManager()`` y ``getTransactionManager()``
   son una manera de manipular :ref:`TransactionManager <TransactionManager>`
   desde el propio objeto :ref:`ConnectionPool <ConnectionPool>`. Utilizarlo
   directamente sigue teniendo el mismo efecto:

   .. code-block:: java

      // Esto equivale a pool.setTransaction()
      TransactionManager.create("BD", pool.getDataSource());

      // Esto equivale a pool.getTransaction()
      TransactionManager tm = Transaction.get("BD");

.. rubric:: Notas al pie

.. [#] Al método sólo se le proporciona la |URL|, porque usamos *SQLite* como
   |SGBD|. Si fuera otro como *MySQL*, tendríamos también que proporcionar un
   usuario y una contraseña. Por otro lado, en el caso particular de *SQLite*
   nos vemos obligados añadir el parámetro :code:`cache=shared` a la |URL|, ya
   que de lo contrario cada conexión que devuelva el *pool* será una base de
   datos distinta en memoria. Con una base de datos persistente, no habría sido
   necesario.

.. [#] Con *SQLite* por ejemplo el método ``.executeUpdate`` sí será capaz de
   ejecutar todas las sentencias |SQL|; ``execute``, en cambio, no lo hará y
   ejecutará solo la primera. Con otros |SGBD| el comportamiento puede variar.

.. |SQL| replace:: :abbr:`SQL (Structured Query Language)`
.. |JDBC| replace:: :abbr:`JDBC (Java DataBase Connectivity)`
.. |SGBD| replace:: :abbr:`SGBD (Sistema Gestor de Bases de Datos)`
.. |URL| replace:: :abbr:`URL (Uniform Resource Locator)`
.. |DataSource| replace:: :java-sql:`DataSource <DataSource>`
.. |ResultSet| replace:: :java-sql:`ResultSet <ResultSet>`
.. |Connection| replace:: :java-sql:`Connection <Connection>`
.. |Statement| replace:: :java-sql:`Statement <Statement>`
.. |Exception| replace:: :java-lang:`Exception <Exception>`
.. _patrón Multiton: https://en.wikipedia.org/wiki/Multiton
.. _HikariCP: https://github.com/brettwooldridge/HikariCP
