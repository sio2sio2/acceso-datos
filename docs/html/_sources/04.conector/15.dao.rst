.. _conn-prog:

Programación con conectores
***************************
Como se ha podido ver hasta aquí, el acceso de una aplicación a una base de
datos relacional es relativamente sencillo y medianamente semejante sea cual
sea el lenguaje de programación y el |SGBD|. Por tanto, el usar de modo básico
conectores no entraña excesiva dificultad. Lo complicado, en realidad, es
abstraer al resto del programa del acceso, de modo que logremos que manipule
puramente objetos, aunque la información no esté almacenada según este modelo
en la base de datos.

Así pues, el propósito a seguir cuando se codifica una aplicación es que todas
las particularidades del acceso a datos estén reducidas a un paquete dentro de
la aplicación (p.ej. llamado *backend*), fuera del cual no haya otra cosa que
objetos.

.. caution:: A continuación se glosa una posible solución, no con la intención
   de que se tome como definitiva, sino con el propósito de que se entienda a
   qué resultado debe llegarse: abstraer completamente la lógica del programa
   del soporte de datos, de modo que, si éste cambia, se reprograme sin que
   cambie en absoluto la lógica.

Para lograr esta abstracción proponemos un patrón |DAO|, que separa por un lado
los objetos del modelo de datos de nuestra aplicación y por otro los objetos que
se encargan del acceso a la base de datos. Ilustrémoslo con un ejemplo muy
sencillo: un conjunto de estudiantes que cursan estudios en centros de
enseñanza:

.. image:: files/er-ec.png
   :name: conn-er-ec

que podemos codificar de este modo:

.. literalinclude:: files/Centro.java
   :language: java

.. literalinclude:: files/Estudiante.java
   :language: java

.. seealso:: Puede encontrar el código completo del ejemplo ilustrativo en los
   test de `este repositorio de GitHub <https://github.com/sio2sio2/sqlutils>`_.

Como puede observarse, las dos definiciones son independientes del soporte de
almacenamiento y responden únicamente a la lógica de la aplicación\ [#]_. Para
simplicar las cosas obligamos a que todas estas clases incluyan un campo
identificador, de ahí que implementen una interfaz ``Entity``:

.. code-block:: java

   public interface Entity {
      public int getId();
      public void setId(int id);
   }

Si estas clases son ajenas a su persistencia, ¿cómo entonces se escribe o
recupera información de la base de datos? Esto es así, porque definiremos otras
clases, una por cada una de las clases del modelo, dedicadas a ello. Por tanto,
deberemos crear una para almacenar y recuperar centros y, otra para almacenar y
recuperar estudiantes.

En principio, para todos los objetos hay que implementar las mismas operaciones
de almacenamiento: inserción, recuperación, borrado y almacenamiento; así que
podemos definir una interfaz que cumplan todas estas clases relacionadas con el
almacenamiento en el backend:

.. literalinclude:: files/Crud.java
   :language: java

.. note:: La interfaz está definida en sqlutils_, pero no forma parte del código
   de prueba, sino de las utilidades.

.. admonition:: Aclaración

   Esta interfaz no tiene por qué ser definida exactamente así: podrían defirnir
   otra que satisfaga también la necesidad de implementar las cuatro operaciones
   básicas. 

Son precisas algunas aclaraciones:

+ La interfaz es genérica, porque una clase orientada a almacenar estudiantes
  deberá recuperar estudiantes o admitir un estudiante cuando desea añadir datos
  a la base de datos, mientras que si está orientada a centros, deberá hacer lo
  propio con centros.

+ El método de inserción de varios objetos puede resultar redundante y,
  de hecho, se facilita una implementación predeterminada que consiste en
  insertar sucesivamente todos. Pero es útil porque da pie a que podamos
  implementar algo más eficiente, si así lo estimamos oportuno.

+ Hemos preferido que la obtención de todos los objetos de una misma clase se
  haga mediante un flujo para lo cual podemos usar el método
  ``SqlUtils.resultToStream`` de sqlutils_. Por supuesto es posible también
  alterar la firma del método para devolver |List|\ [#]_.

+ La obtención de un objeto a partir de su identificador puede resultar
  infructuosa, si tal objeto no existe en el almacenamiento. Por ese motivo se
  ha preferido devolver :java-util:`Opcional <Optional>` en vez de directamente
  el objeto.

+ Todas estas operaciones son susceptibles de generar excepciones (típicamente
  |SQLException| si la base de datos es relacional), así que hemos definido una
  excepción propia para abstraernos de cuál es la excepción particular del
  soporte de almacenamiento.

Esta, pues, es la interfaz que cumplirán todas las clases encargadas de
comunicarse con la base de datos para extraer o guardar datos. Implementemos
ahora la clase para extraer o guardar objetos ``Centro``:

.. literalinclude:: files/CentroSqlite.java
   :language: java
   :start-at: public class

Este objeto ``CentroSqlite`` implementa en particular la interfaz ``Crud`` para
los objetos ``Centro`` y una base de datos SQLite. Si observamos la
implementación de cualquiera de las operaciones |CRUD|, veremos que consiste en
poner en práctica lo aprendido anteriormente: se abre una conexión, se construye
ls sentencia |SQL| apropiada y se ejecuta para realizar la operación. Tan sólo
el método que devuelve un ``Stream`` se sale un poco de esta regla por las
particularidades del propio ``Stream``:

.. code-block:: java

   @Override
   public Stream<Centro> get() throws DataAccessException {
       final String sqlString = "SELECT * FROM Centro";
       
       try {
           Connection conn = cp.getConnection();
           Statement stmt = conn.createStatement();
           ResultSet rs = stmt.executeQuery(sqlString);

           return SqlUtils.resultSetToStream(cp.isCloseable()?conn:stmt, rs, CentroSqlite::resultToCentro);
       }
       catch(SQLException err) {
           throw new DataAccessException(err);
       }
   }

Obsérvese que en este método, a diferencia de los anteriores, no cerramos la
conexión, ni la sentencia, ni el resultado, ya que de lo contrario no podremos
obtener centros del ``Stream`` devuelto. Quien se encargará de cerrar finalmente
todo será el propio flujo cuando se cierre, por lo que convendrá usar con él un
*try-with-resources*. Además, el primer argumento que recibe
``SqlUtils.resultToStream`` es aquello que debe cerrarse cuando se acaba de
usar el objeto y se desea cerrar; y que puede que sea la conexión o puede que sea
la sentencia. Qué sea depende de cómo hayamos creado este objeto de
comunicación con la base de datos: más adelante daremos las explicaciones.

En principio, cada operación parece abrir una conexión propia y cerrarla al
acabar (excepto este último método por la particularidad ya referida). Si se
utiliza un :ref:`pool de conexiones <conn-pool>` y se facilita para la creación
del objeto el |DataSource| correspondiente, esto no penaliza prácticamente
el rendimiento y es muy cómodo. El problema de que cada operación abra y cierre
su propio objeto |Connection| es que nos quedamos sin poder reunir en una misma
transacción dos o más operaciones, ya que las operaciones que constituyen una
transacción deben compartir la conexión.

En consecuencia, si lo requiere la circunstancia (definir una transacción con
varias operaciones), necesitamos poder crear estos objetos a partir de una
conexión ya existente y que sus métodos la usen sin cerrarla. Para no duplicar
código, hemos acudido a una argucia: un objeto ``ConnectionProvider`` que
enmascara el hecho de que hayamos creado el objeto a partir de un |DataSource| o
un |Connection| compartido, en cuyo último caso no hay que cerrarlo, aun cuando
estemos usando una estructura *try-with-resources*, y aparentemente se cierre.
Por esta razón, las conexiones se obtienen a partir de un atributo ``cp``
(definido en ``AbstractDao`` como un ``ConnectionProvider``).  Esta es también
la razón por la que se pasa a ``SqlUtils.resultToStream`` a veces una conexión
(cuando la conexion la creó el propio método a partir de un |DataSource|) y a
veces una sentencia (cuando se usa una conexión preexistente que no debe
cerrarse)\ [#]_.

Necesitamos también crear una clase para la persistencia de los objetos
``Estudiante``. La clase ``EstudianteSqlite`` es semejante a la anterior, pero
hay una gran diferencia: uno de los atributos de ``Estudiante`` es un centro, lo
que supone que en la base de datos el campo es una clave foránea (un entero) que
hace referencia al registro de otra tabla. El problema de esta circunstancia se
produce cuando deseemos generar un objeto ``Estudiante`` a partir de una
operación de lectura (``.get`` en nuestra interfaz), ya que la consulta nos
devolverá el identificador del centro, no el centro en sí. Para abordar esta
dificultad tenemos dos vías:

+ Obtener automáticamente también el centro asociado al obtener el estudiante.
+ No hacerlo y posponer su obtención hasta que sea realmente necesario: cuando
  en la aplicación se ejecute el método ``.getCentro()``.

La primera vía es sencilla, aunque menos eficiente: si nunca llegamos a usar el
centro, habremos hecho una segunda consulta\ [#]_ inútil. La segunda vía es
perezosa, pero tiene el inconveniente de que es más difícil de implementar, ya
que pasa por crear un objeto proxy que almacene inicialmente el identificador
del centro e intercepte las llamadas al método ``.getCentro()`` para que haga la
consulta con dicho identificador. En cualquier caso, tal implementación está
hecha en sqlutils_. Veamos cómo usar esta implementación:

.. code-block:: java

   private static Estudiante resultToEstudiante(ResultSet rs, DataSource ds) throws SQLException {
       int id = rs.getInt("id_estudiante");
       String nombre = rs.getString("nombre");
       Integer idCentro = rs.getInt("centro");
       if(rs.wasNull()) idCentro = null;
       LocalDate nacimiento = rs.getDate("nacimiento").toLocalDate();

       Estudiante estudiante = new Estudiante();
       Centro centro = null;

       // Carga inmediata: obtenemos inmediatamente el centro.
       //if(IdCentro != null) centro = new CentroSqlite(ds).get(IdCentro).orElse(null);

       // Carga perezosa: proxy al que se le carga la clave foránea
       estudiante = new FkLazyLoader<>(estudiante)
                     .setFk("centro", idCentro, new CentroSqlite(cp))
                     .createProxy();

       // Cargamos datos en el objeto y entregamos.
       return estudiante.cargarDatos(id, nombre, nacimiento, centro);
   }

Con lo hecho hasta ahora, tenemos definidas las clases del modelo y las clases
que permiten hacer persistentes los objetos de dichas clases (|DAO|). Éstas
últimas relacionan la aplicación con la base de datos, por lo que la
persistencia debería hacerse a través de ellas sin jamás hacer referencia a un
objeto ``Connection`` o prepararemos una sentencia |SQL|. Así, pues, para la
persistencia de un objeto ``Centro`` debería utilizar un objeto de la clase
``CentroSqlite`` y para la persistencia de la clase ``Estudiante``, un objeto de
la clase ``EstudianteSqlite``.

Sin embargo para simplificar el uso, las utilidades definen una clase llamada
``Dao`` que permite registrar las clases |DAO| que se utilizarán a través de
ella, y usar esta única clase para hacer persistentes todos los objetos, sean de
la clase que sean (en nuestro ejemplo, centros y estudiantes). Dicho de otra
forma, si ``ds`` es un |DataSource|, en vez de:

.. code-block:: java

   // Esto se definió así en algún sitio.
   Crud<Centro> centroDao = new CentroSqlite(ds);
   Crud<Estudiante> estudianteDao = new EstudianteSqlite(ds);

   // Y me permite operar:
   centroDao.insert(centro);
   Centro castillo = centroDao.get(11004866);
   Estudiante perico = estudianteDao.get(1);

haré esto otro:

.. code-block:: java

   // Esto se definirá en algún sitio
   Dao dao = new Dao(ds, CentroSqlite.class, EstudianteSqlite.class);

   // Y operaré siempre a través de él.
   dao.insert(centro);
   Centro castillo = dao.get(Centro.class, 11004866);  // Hay que decir si quiero centros o estudiantes.
   Estudiante perico = dao.get(Estudiante.class, 1);   // Ídem.


Finalmente, necesitamos también una clase que gestione la conexión a la base de
datos y que se encargue de:

.. _rst-class: simple

#. Crear el pool de conexiones con el |DataSource| apropiado.
#. Realizar labores de inicialización como, por ejemplo, cuando la base de datos
   está vacía, poblarla con el esquema.
#. Proporcionar al resto el objeto ``Dao`` que facilita la persistencia de
   centros y estudiantes.
#. Habilitar algún mecanismo sencillo para que dos o más operaciones de
   almacenamiento se realicen en una misma transacción.

Por ello, las utilidades definen una interfaz que deben cumplir todas estas
clases de conexión\ [#]_:

.. literalinclude:: files/DaoConnection.java
   :language: java
   :start-at: public interface

De la interfaz sólo exige aclaración el modo escogido para generar
transacciones. Dado que debemos cumplir el principio de operar siempre a través
de objetos |DAO|, hemos diseñado las transacciones para que se escriban así:

.. _conn-transaccion-impl:

.. code-block:: java

   try {
      transaccion( (centroDao, estudianteDao) -> {
         // Estos objetos DAO usan la misma conexión
         // para realizar todas las operaciones y, además,
         // todas están en la misma transacción, p.ej.
         estudianteDao.insert(estudiante1);
         estudianteDao.insert(estudiante2);
      });
   }
   catch(DataAccessException err) {
      // Tratamiento del error (el rollback está ya hecho).
   }

La implementación particular para una conexión queda así:

.. literalinclude:: files/ConexionSqlite.java
   :language: java

La implementación es sencilla de entender: se crea un pool de conexiones al
crear el objeto, se puebla la base de datos en caso de no existir previamente;
y, con los métodos correspondientes, se devuelven instancias de las clases
``CentroSqlite`` y ``EstudianteSqlite`` a las que se ha pasado el |DataSource|
para su construcción. Por tanto, los objetos |DAO| generados no podrán usarse
para crear transacciones con varias operaciones. Dos apostillas requiere, no
obstante, el código:

+ El |DataSource| para el pool de conexiones se crea con ayuda de una clase
  abstracta ``AbstractDsCache`` que va almacenando los *pools* de conexiones ya
  creados en una caché y, si ya se creó uno para las mismas ``opciones``, en vez
  de crear uno nuevo, devuelve el correspondiente ya creado. Como en el caso de
  SQLite no hay credenciales, la base de datos sólo está determinada por su
  |URL|, así que la clave que sirve para cachear el objeto |DataSource| se
  genera exclusivamente con ella.

+ Cómo logramos escribir transacciones del modo que :ref:`se dejó escrito arriba
  <conn-transaccion-impl>`:

  .. code-block:: java

     @Override
     public void transaccion(Transaccionable operaciones) throws DataAccessException {
         try(Connection conn = ds.getConnection()) {
             TransactionManager.transactionSQL(conn, c -> {
                 operaciones.run(new CentroSqlite(c), new EstudianteSqlite(c));
             });
         }
         catch(SQLException err) {
             throw new DataAccessException(err);
         }
     }

  Básicamente, crea un conexión y dos objetos |DAO| que usan esa misma conexión,
  por lo que todas las operaciones hechas con ambos podrán formar parte de una
  transacción. Estos dos objetos son los que recibe como argumento la
  :ref:`función lambda que debe escribirse en el código del programa
  <conn-transaccion-impl>`. Gracias a ``transactionSQL`` de sqlutils_, todas las
  operaciones incluidas en esta función lambda, forman parte de una misma
  transacción.

.. warning:: Como el método ``transaccion`` crea su propia conexión, no es
   anidable.  Es una limitación que se podría intentar subsanar, implementando
   de otro modo las transacciones (puesto que ``transactionSQL`` sí es
   compatible con la anidación).

Como nuestra aplicación puede manejar varios |SGBD| distintos, tendremos que
realizar implementaciones análogas para todos ellos e implementar un `patrón
Factory <https://www.arquitecturajava.com/patron-factory-para-que-sirve/>`_ que
escoja el tipo adecuado de conexión.

Hecho eso, la relación con la base de datos está totalmente encapsulada como
puede verse `en las pruebas de uso que incluye Test.java
<https://github.com/sio2sio2/sqlutils/blob/main/src/test/java/edu/acceso/sqlutils/Test.java>`_.

.. rubric:: Notas al pie

.. [#] Hemos incluido, eso sí, una anotación en el campo ``centro`` de
   ``Estudiante`` que lo identifica como clave foránea. Pero no deja de ser una
   mera anotación que además no es indispensable. Esta anotación está definida en sqlutils_.

.. [#] La ventaja de ``Stream`` es su evaluación perezosa; las desventajas son
   dos: nos veremos obligados a usar sqlutils_ y, además, se debe ser más
   cuidadoso al utilizarla ya que debemos asegurarnos de que quien cierra la
   conexión es el propio Stream.

.. [#] De todos modos, en caso de que pasáramos la conexión cuando hemos creado
   el objeto con una conexión, la conexión no se cerraría, porque la hemos
   manipulado para que no sea así (recordemos que la manejamos a través de
   ``ConnectionProvider`` y no directamente); y la sentencia quedaría sin cerrar
   hasta que no se cerrara la conexión fuera del objeto.

.. [#] En realidad, en vez de hacer una segunda consulta, podríamos hacer una
   consulta compuesta para obtener estudiante y centro.

.. [#] En realidad, la interfaz satisface los dos últimos requisitos. Los dos
   primeros deben resolverse automáticamente al crear el objeto, así que no son
   necesarios métodos: se implementarán a través del constructor.

.. _sqlutils: https://github.com/sio2sio2/sqlutils

.. |DAO| replace:: :abbr:`DAO (Data Access Object)`
.. |CRUD| replace:: :abbr:`CRUD (Create, Read, Update, Delete)`
.. |SGBD| replace:: :abbr:`SGBD (Sistema Gestor de Bases de Datos)`
.. |List| replace:: :java-util:`List <List>`.
.. |SQL| replace:: :abbr:`SQL (Structured Query Language)`
.. |URL| replace:: :abbr:`URL (Uniform Resource Locator)`
.. |DataSource| replace:: :javax-sql:`DataSource <DataSource>`
.. |Connection| replace:: :java-sql:`Connection <Connection>`
.. |Statement| replace:: :java-sql:`Statement <Statement>`
.. |SQLException| replace:: :java-sql:`SQLException <SQLException>`
