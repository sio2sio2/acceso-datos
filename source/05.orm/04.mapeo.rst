.. _orm-mapping:

Mapeo
*****
El :dfn:`mapeo` consiste en definir cómo se hará la traducción entre las clases
del modelo de objetos (de *Java*, en este caso) y las entidades del modelo
relacional. En esta traducción las clases se corresponden con las tablas, las
instancias con los registros y los atributos con los campos.

En Hibernate_, la definición del *mapeo* puede realizarse con anotaciones
siguiendo el estándar |JPA|. Bajo este epígrafe aprenderemos fundamentalmente:

- Cómo marcar los atributos para que se incorporen a los campos de la tabla.
- Cómo marcar que los atributos representan relaciones entre tablas.

Anotaciones básicas
===================
Ya introdujimos las anotaciones más básicas al presentar el :ref:`ejemplo de
anotación de la clase Centro <orm-bas-map>`:

.. literalinclude:: files/Centro.java
   :language: java
   :start-at: @Entity

Y convendría leer lo explicado allí para no repetirlo. Ahora bien: podemos
ampliar nuestro conocimientos sobre las anotaciones válidas:

``@Column``/``@Transient``
   Por lo general, todos los atributos de la clase, aunque no estén anotados en
   absoluto, se consideran campos de la tabla correspondiente. Las excepciones
   son:

   - Los campos estáticos (``static``), ya que no forman parte del objeto.
   - Los campos con el modificador ``transient``.
   - Los atributos sin *getter* o al menos con un *getter* que no sea accesible
     (``private``)\ [#]_.
   - Los atributos cuyo tipo no se sepa traducir.
   - Los atributos que se heredan de una clase base que no se anotó con
     ``@Entity``.

   La anotación ``@Column`` fuerza a que un atributo se traduzca a campo y
   además permite añadir información sobre la traducción mediante parámetros:

   + ``name`` permite indicar un nombre para el campo distinto al nombre del atributo.
   + ``nullable``, si puede contener valores nulos.
   + ``unique``, si su valor debe ser único.
   + ``length``, la longitud de la cadena.
   + ``precision`` y ``scale`` para tipos como :java-util:`BigDecimal
     <BigDecimal>` permiten indicar el número total de dígitos y el de dígitos
     decimales respectivamente.
   + ``insertable``, indica si el campo debe incluirse en las sentencias
     ``INSERT``.
   + ``updatable``, indica si el campo debe incluirse en las sentencias
     ``UPDATE``.
   + ``columnDefinition`` sirve para indicar directamente la definición |SQL|
     del campo.

   La anotación ``@Transient`` evita que el atributo se mapee como campo.

``@Id``/``@GeneratedValue``
   Como ya hemos visto, la anotación ``@Id`` sirve para marcar un atributo como
   identificador; y ``@GeneratedValue`` para indicar cómo se generan
   automáticamente sus valores. Lo más socorrido es:

   .. code-block:: java

      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id

   que equivale a indicar que el campo identificador es autoincremental
   (``GENERATED ALWAYS AS IDENTITY``). Si no usamos la segunda anotación el
   campo requerirá siempre que el usuario establezca el valor.

``@Lob``
   Se utiliza para campos que contienen cantidades apreciables de datos (``BLOB``
   o ``CLOB``) en el estándar:

   .. code-block:: java

      @Lob
      private byte[] foto;

``@Temporal``
   Es útil cuando se usa el tipo antiguo :java-util:`Date <Date>` para indicar
   si se quiere almacenar en la base de datos, sólo la hora
   (``TemporalType.TIME``) , sólo la fecha (``TemporalType.DATE``) o tanto la
   fecha como la hora (``TemporalType.TIMESTAMP``):

   .. code-block:: java

      @Temporal(TemporalType.DATE)  // Sólo almacena la fecha.
      private Date nacimiento;


   Para tipos modernos como :java-time:`LocalDate <LocalDate>`,
   :java-time:`LocalTime <LocalTime>` o :java-time:`LocalDateTime
   <LocalDateTime>` es absolutamente innecesaria la anotación.

``@Version``
   Sirve para identificar el atributo como un campo que controla la versión del
   registro, de modo que se actualiza el valor cada vez que se actualiza. Por
   ejemplo:

   .. code-block:: java

      @Version
      private int version;

   El atributo debe ser numérico, o si se desea almacenar la fecha en vez de
   un número de versión, un tipo de fecha. Por ejemplo:

   .. code-block:: java

      @Version
      @Column(nullable = false)
      private LocalDateTime actualizacion;

``@Enumerated``
   Permite indicar cómo almacenar un campo ``enum``:

   .. code-block:: java

      @Enumerated(EnumType.STRING)
      @Column(nullable = false)
      private Titularidad titularidad

   En este caso, el tipo se guardará como una cadena en la base de datos. Otra
   opción habría sido ``EnumType.ORDINAL``.

   .. _orm-ann-embedded:

``@Embeddable``/``@Embedded``
   Ambas trabajan *en comandita* y permiten empotrar un objeto completo como
   campo de una tabla. Por ejemplo, si añadiéramos un campo *dirección* a la
   definición de ``Centro``, podríamos hacer lo siguiente:

   .. code-block:: java

      @Embeddable
      public class Direccion {
         private String calle;
         private String numero;
         private String localidad;
         private Integer codigoPostal;

         // ... getters y setters ...
      }

      // ...

      public class Centro {
         // ...

         @Embedded
         private Direccion direccion;

         // ...
      }

   Al traducirse, no se crea una tabla *Direccion*, sino que los atributos de
   ``Direccion`` pasarán a añadirse como atributos de la tabla *Centro*. Para
   controlar con qué nombre de columna se traducen es necesario:

   .. code-block:: java

      @Embedded
      @AttributeOverrides({
         @AttributeOverride(name = "calle", column = @Column(name = "d_calle")),
         @AttributeOverride(name = "numero", column = @Column(name = "d_numero"))
      })
      private Direccion direccion;

``@Convert``/``@Converter``
   Permite definir exactamente la traducción de un atributo a campo y viceversa.
   Para llevar a cabo esta traducción debe definirse una clase que implemente la
   interfaz ``AttibuteConverter``. Por ejemplo, imaginemos que el tipo
   ``Titularidad`` lo hubiéramos definido así:

   .. code-block:: java

      public enum Titularidad {
         PUBLICA("Pública"),
         PRIVADA("Privada");

         private String nombre;

         Titularidad(String nombre) {
            this.nombre = nombre;
         }

         public String getNombre() {
            return nombre;
         }

         public static Titularidad fromNombre(String nombre) {
            return Arrays.stream(Titularidad.values())
               .filter(t -> t.getNombre().toLowerCase().equals(nombre.toLowerCase()))
               .findFirst.orElse(null);
         }
      }

   y que pretendiéramos almacenar en la base de datos el *nombre* ("Pública" o
   "Privada"). En ese caso tendríamos que definir un convesor así:

   .. code-block:: java

      public class TitularidadConverter implements AttributeConverter<Titularidad, String> {

           @Override
           public Titularidad convertToEntityAttribute(String nombre) {
               return Titularidad.fromNombre(nombre);
           }

           @Override
           public String convertToDatabaseColumn(Titularidad titularidad) {
               return titularidad == null?null:titularidad.getNombre();
           }
           
       }

   De esto modo podríamos anotar el atributo así:

   .. code-block:: java

      @Convert(converter = TitularidadConverter.class)
      private Titularidad titularidad;
    
   También es posible anotar la clase conversora:

   .. code-block:: java

      @Converter(autoPlay = true)
      public class TitularidadConverter implements AttributeConverter<Titularidad, String> {
         // ... Implementación ...
      }

   Y el conversor se aplicará automáticamente a todos los atributos de tipo
   ``Titularidad`` sin  necesidad de anotar los atributos individualmente.

Relaciones
==========
Las relaciones entre las entidades también se significan mediante anotaciones.
Hay tres tipos de relaciones binarias en el modelo relacional:

**Relación 1:N**: ``@OneToMany``/``@ManyToOne``
   Se produce cuando una registro de la primera tabla se relaciona con muchos
   registros de la segunda, pero al contrario los registros de la segunda sólo
   se relacionan con uno de la primera. Se resuelve colocando un campo en la
   tabla cuyos registros se relacionan con uno y sólo un registro de la otra
   tabla. Para significarla se usan las anotaciones ``@OneToMany`` y
   ``@ManyToOne``, ya que --y esto es de suma importancia-- al anotar la
   relación entre clases, ésta debe reflejarse en ambos extremos, esto es, en
   las dos clases. Por eso, la relación **1:N** entre *Centro* y *Estudiante*
   provoca que definamos así la clase ``Estudiante``:

   .. literalinclude:: files/Estudiante.java
      :language: java
      :start-at: @Entity
      :emphasize-lines: 13-15

   .. caution:: Recuerde registrar en la configuración esta nueva clase:

      .. code-block:: xml

         <mapping class="edu.acceso.test_hibernate.modelo.Estudiante"/>

   Es de reseñar es esta definición:

   + Cómo se ha definido la relación.
   + Que este atributo, como los demás, tiene *setter* y *getter*.
   + Que el constructor con argumentos y ``cargarDatos`` no fijan ningún
     identificador, ya que éste lo establece la base de datos al guardar el objeto.

   Ahora bien, hemos dicho que tenemos que anotar los dos extremos de la relación,
   así que deberemos añadir un campo a la clase ``Centro`` que sea una lista de
   estudiantes, ya que en un centro hay muchos estudiantes:

   .. code-block:: java

      @OneToMany(mappedBy = "centro")  //Ya está mapeado.
      private List<Estudiante> estudiantes;

   Como se ve, expresamos que este campo ya está mapeado por el atributo ``centro``
   de la clase ``Estudiante``. Además, deberemos definirle un *getter* para poder
   acceder a su valor. El *setter*, en cambio, no es indispel *setter*, en cambio,
   no es indispensable.

**Relación 1:1**: ``@OneToOne``
   Expresa que cada registro de una tabla se relaciona exclusivamente con uno (o
   ninguno) registro de la otra tabla. Se resuelve colocando el campo en cualquiera
   de las dos tablas. Para significar este tipo relaciones se usa la notación
   ``@OneToOne``. Para definir con Hibernate_ tal relación hemos de obrar de
   manera análoga a como hicimos con la relación **1:N**. Para ilustrarlo,
   supongamos que añadimos un campo ``dirección`` a la clase ``Centro`` de tipo
   ``Direccion`` y queremos que en la base de datos los campos que componen la
   dirección se mantengan en una tabla independiente (a diferencia de lo que
   propusimos al explicar la :ref:`anotación @Embedded <orm-ann-embedded>`). En
   este caso, la relación **1:1** se expresaría añadiendo a ``Centro``:

   .. code-block:: java

      @OneToOne
      @JoinColumn(name = "direccion_id", nullable = false)
      private Direccion direccion;

   Y, además, deberíamos definir el *getter* y el *setter* correspondientes. 
   Éste sería el extremo que tendría representación en la base de datos.
   En el otro extremo de la relación, la clase ``Direccion`` debería añadir:

   .. code-block:: java

      @OneToOne(mappedBy = "direccion")
      private Centro centro;

   más al menos el *getter* correspondiente.

**Relación N:M**:
   La relación sopone que un registro de una tabla se relaciona con muchos de la
   otra, y viceversa; y supone en el modelo relacional la aparición de una
   tercera tabla. En nuestro ejemplo, podríamos introducir este tipo de
   relación, si ampliáramos la base de datos para que incluyera profesores y los
   quisiéramos relacionar con estudiantes, ya que los estudiantes tienen varios
   profesores; y cada profesor imparte sus enseñanzas a varios estudiantes. Por
   tanto, la relación entre las tablas *Profesor* y *Estudiante* es una relación
   **N:M**. Para implementar en Hibernate_ estas relaciones, han de distinguirse
   dos casos:

   a. La relación no tiene atributos propios: ``@ManyToMany``.

      En este caso, puede expresarse la relación **N:M** directamente con
      la anotación ``@ManyToMany`` y como en el caso anterior, habrá que
      expresarla en los dos extremos (las dos clases). En cuál hagamos
      propiamente la definición y en cuál indiquemos que se relaciona con la
      otra (a través de ``mappedBy``) es cosa nuestro y dependerá más bien de
      qué nos resulte más natural. Así podríamos añadir a ``Estudiante``:

      .. code-block:: java

         @ManyToMany
         @JoinTable(
            name="Estudiante_Profesor", // Nombre de la tabla adicional
            joinColums = @JoinColumn(name = "id_estudiante"),
            inverseJoinColums = @JoinColumn(name = "id_profesor"),
         )
         private List<Profesor> profesores;

      y a ``Profesor``:

      .. code-block:: java

         @ManyToMany(mappedBy = "profesores")
         private List<Estudiante> estudiantes;
   
      Deberemos crear los *getters* para ambos atributos, pero no son necesarios
      los *setters*.

   #. La relación tiene atributos propios: ``@OneToMany``/``@ManyToOne``.

      En tal caso, el único modo de poder añadir los atributos es crear una
      clase adicional que añada los atributos, y descomponer la relación **N:M**
      en dos relaciones **1:N**, de ahí que las anotaciones apropiadas sean
      ``@OneToMany`` y ``@ManyToOne``. No entraremos en detalle, porque ya hemos
      resuelto cómo expresar una relación **1:N**.

.. rubric:: Notas al pie

.. [#]  Esto, sin embargo, es así, porque por defecto el acceso es por
   propiedades (a través del *getter*) y no por atributos. Se puede alterar el
   comportamiento añadiendo la anotación ``@Access(AccessType.FIELD)`` a la
   clase.

.. |JPA| replace:: :abbr:`JPA (Java Persisten API)`
.. |SQL| replace:: :abbr:`SQL (Structured Query Language)`
.. _Hibernate: https://www.hibernate.org
