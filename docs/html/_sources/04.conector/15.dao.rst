Programación con conectores
***************************
Como se ha podido ver hasta aquí, el acceso de una aplicación a una base de
datos relacional es relativamente sencillo y medianamente semejante sea cual
sea el lenguaje de programación y el |SGBD|. Por tanto, el usar de modo básico
conectores no entraña excesiva dificultad. Lo complicado, en realidad, es
abstraer al resto del programa del acceso, de modo que logremos que manipule
puramente objetos, aunque la información no esté almacenada según este modelo
en la base de datos.

Para lograr esta abstracción proponemos un patrón |DAO|, que separa por un lado
los objetos del modelo de datos de nuestra aplicación y por otro los objetos que
se encargan del acceso a la base de datos. Ilustrémoslo con un ejemplo muy
sencillo: un conjunto de estudiantes que cursan estudios en centros de
enseñanza:

.. image:: files/er-ec.png

que podemos codificar de este modo:

.. literalinclude:: files/Centro.java
   :language: java

.. literalinclude:: files/Estudiante.java
   :language: java

.. seealso:: Puede encontrar el código completo del ejemplo ilustrativo en los
   test de `este repositorio de GitHub <https://github.com/sio2sio2/sqlutils>`_.

Como puede observarse, las dos definiciones son independientes del soporte de
almacenamiento y responden únicamente a la lógica de la aplicación\ [#]_. Para
simplicar las cosas obligamos a que todas estas clases incluyan un campo
identificador, de ahí que implementen una interfaz ``Entity``:

.. code-block:: java

   public interface Entity {
      public int getId();
      public void setId(int id);
   }

Si estas clases son ajenas a su persistencia, ¿cómo entonces se escribe o
recupera información de la base de datos? Esto es así, porque definiremos otras
clases, una por cada una de las clases del modelo, dedicadas a ello. Por tanto,
deberemos crear una para almacenar y recuperar centros y, otra para almacenar y
recuperar estudiantes.

En principio, para todos los objetos hay que implementar las mismas operaciones
de almacenamiento: inserción, recuperación, borrado y almacenamiento; así que
podemos definir una interfaz que cumplan todas estas clases relacionadas con el
almacenamiento en el backend:

.. literalinclude:: files/Crud.java
   :language: java

.. note:: La interfaz está definida en sqlutils_, pero no forma parte del código
   de prueba, sino de las utilidades.

.. admonition:: Aclaración

   Esta interfaz no tiene por qué ser definida exactamente así, pero
   básicamente implementa todas esas operaciones.

Son precisas algunas aclaraciones:

+ La interfaz es genérica, porque una clase orientada a almacenar estudiantes
  deberá recuperar estudiantes o admitir un estudiante cuando desea añadir datos
  a la base de datos, mientras que si está orientada a centros, deberá hacer lo
  propio con centros.

+ El método de inserción de varios objetos puede resultar redundante y,
  de hecho, se facilita una implementación predeterminada que consiste en
  insertar sucesivamente todos. Pero es útil porque da pie a que podamos
  implementar algo más eficiente, si así lo estimamos oportuno.

+ Hemos preferido que la obtención de todos los objetos de una misma clase se
  haga mediante un flujo para lo cual podemos usar el método
  ``SqlUtils.resultToStream`` de sqlutils_. Por supuesto es posible también
  alterar la firma del método para devolver |List|\ [#]_.

+ La obtención de un objeto a partir de su identificador puede resultar
  infructuosa, si tal objeto no existe en el almacenamiento. Por ese motivo se
  ha preferido devolver :java-util:`Opcional <Optional>` en vez de directamente
  el objeto.

+ Todas estas operaciones pueden provocar problemas de acceso
  (típicamente |SQLException| si la base de datos es relacional), así que hemos
  definido una excepción propia para abstraernos de cuál es la excepción propia
  del soporte de almacenamiento.

Esta, pues, es la interfaz que cumpliran todas las clases encargadas de
comunicarse con la base de datos para extraer o guardar datos. Implementemos
ahora la clase para extraer o guardar objetos ``Centro``:

.. literalinclude:: files/CentroSqlite.java
   :language: java

Este objeto ``CentroSqlite`` implementa en particular la interfaz ``Crud`` para
los objetos ``Centro`` y una base de datos SQLite. Si observamos la
implementación de cualquiera de las operaciones |CRUD|, veremos que consiste en
poner en práctica lo aprendido anteriormente: se abre una conexión, se construye
ls sentencia |SQL| apropiada y se ejecuta para realizar la operación. Tan sólo
el método que devuelve un ``Stream`` se sale un poco de esta regla por las
particularidades del propio ``Stream``:

.. code-block:: java

   @Override
   public Stream<Centro> get() throws DataAccessException {
       final String sqlString = "SELECT * FROM Centro";
       
       try {
           Connection conn = cp.getConnection();
           Statement stmt = conn.createStatement();
           ResultSet rs = stmt.executeQuery(sqlString);

           return SqlUtils.resultSetToStream(cp.isCloseable()?conn:stmt, rs, CentroSqlite::resultToCentro);
       }
       catch(SQLException err) {
           throw new DataAccessException(err);
       }
   }

Obsérvese que en este método, a diferencia de los anteriores, no cerramos la
conexión, ni la sentencia, ni el resultado, ya que de lo contrario no podremos
obtener centros del ``Stream`` devuelto. Quien se encargará de cerrar finalmente
todo será el propio flujo cuando se cierre, por lo que convendrá usar con él un
*try-with-resources*. Además, el primer argumento que recibe
``SqlUtils.resultToStream`` es aquello que debe cerrarse cuando se acaba de
usar el objeto y se desea cerrar; y que puede que sea la conexión o puede que sea
la sentencia. Qué sea depende de cómo hayamos creado este objeto de
comunicación con la base de datos; y esta es la última explicación que ha de
darse sobre él.

En principio, cada operación parece abrir una conexión propia y cerrarla al
acabar (excepto este último método por la particularidad ya referida). Si se
utiliza un :ref:`pool de conexiones <conn-pool>` y se facilita para la creación
del objeto el |DataSource| correspondiente, esto no penaliza prácticamente
el rendimiento y es muy cómodo. El problema de que cada operación abra y cierre
su propio objeto |Connection| es que nos quedamos sin poder reunir en una misma
transacción dos o más operaciones, ya que para que puedan formar parte de una,
necesitan compartir la conexión.

En consecuencia, si lo requiere la circunstancia (definir una transacción con
varias operaciones), necesitamos poder crear estos objetos a partir de una
conexión ya creada y que sus métodos la usen sin cerrarla. Para no duplicar
código, hemos acudido a una argucia: un objeto ``ConnectionProvider`` que
enmascara el hecho de que hayamos creado el objeto a partir de un |DataSource| o
un |Connection| compartido y que deja sin cerrar la conexión, aunque se use una
estructura *try-with-resources*, en caso de que estemos usando una conexión que
queremos compartir entre objetos y métodos. Por esta razón, las conexiones se
obtienen a partir de un atributo ``cp`` (definido en ``AbstractDao`` como un
``ConnectionProvider``). Esta es también la razón por la que pasado a
``SqlUtils.resultToStream`` a veces una conexión (cuando el propio método la
creó a partir de un |DataSource|) y a veces una sentencia (cuando se usa una
conexión preexistente)\ [#]_.


Necesitamos también crear una clase para la persistencia de los objetos
``Estudiante``. La clase ``EstudianteSqlite`` es semejante a la anterior, pero
hay una gran diferencia: uno de los atributos de ``Estudiante`` es un centro, lo
que supone que en la base de datos el campo es una clave foránea (un entero) que
hace referencia al registro de otra tabla. El problema de esta circunstancia se
produce cuando deseemos generar un objeto ``Estudiante`` a partir de una
operación de lectura (``.get`` en nuestra interfaz), ya que la consulta nos
devolverá el identificador del centro, no el centro en sí. Para abordar esta
dificultad tenemos dos vías:

+ Obtener automáticamente también el centro asociado al obtener el estudiante.
+ No hacerlo y posponer su obtención hasta que sea realmente necesario: cuando
  en la aplicación se ejecute el método ``.getCentro()``.

La primera vía es sencilla, aunque menos eficiente: si nunca llegamos a usar el
centro, habremos hecho una segunda consulta\ [#]_ inútil. La segunda vía es
perezosa, pero tiene el inconveniente de que es más difícil de implementar, ya
que pasa por crear un objeto proxy que almacene inicialmente el identificador
del centro e intercepte las llamadas al método ``.getCentro()`` para que haga la
consulta con dicho identificador. En cualquier caso, tal implementación está
hecha en sqlutils_. Veamos cómo usar esta implementación:

.. code-block:: java

   private static Estudiante resultToEstudiante(ResultSet rs, DataSource ds) throws SQLException {
       int id = rs.getInt("id_estudiante");
       String nombre = rs.getString("nombre");
       Integer idCentro = rs.getInt("centro");
       if(rs.wasNull()) idCentro = null;
       LocalDate nacimiento = rs.getDate("nacimiento").toLocalDate();

       Estudiante estudiante = new Estudiante();
       Centro centro = null;

       // Carga inmediata: obtenemos inmediatamente el centro.
       //if(IdCentro != null) centro = new CentroSqlite(ds).get(IdCentro).orElse(null);

       // Carga perezosa: proxy al que se le carga la clave foránea
       estudiante = new FkLazyLoader<>(estudiante)
                     .setFk("centro", idCentro, new CentroSqlite(cp));
                     .createProxy();

       // Cargamos datos en el objeto y entregamos.
       return estudiante.cargarDatos(id, nombre, nacimiento, centro);
   }

Con lo hecho hasta ahora, tenemos definidas las clases del modelo y las clases
que permiten hacer persistentes los objetos de dichas clases (|DAO|).
Necesitamos también una clase para la conexión a la base de datos que se
encargue de:

+ Crear el pool de conexiones con el |DataSource| apropiado.
+ Realizar labores de inicialización. Por ejemplo, si la base de datos está
  vacía que la pueble con el esquema.
+ Que proporcione al resto de la aplicación los dos objetos |DAO| asociados a la
  persistencia de centros y estudiante.

-- SEGUIR POR AQUÍ...

Por tanto, esta clase para la conexión, sea cual sea el |SGBD|, tendrá que
cumplir esta interfaz:

.. literalinclude:: files/Conexion.java
   :language: java

Y la clase en sí tendrá esta implementación:

.. literalinclude:: files/ConexionSqlite.java
   :language: java

Como nuestra aplicación puede manejar varios |SGBD| distintos, tendremos que
realizar implementaciones análogas para todos ellos e implementar un `patrón
Factory <https://www.arquitecturajava.com/patron-factory-para-que-sirve/>`_ que
escoja el tipo adecuado de conexión.

Hecho eso, relacionarnos con la base de datos está totalmente encapsulado:

.. code-block:: java

   DateTimeFormatter formato = DateTimeFormatter.ofPattern("dd/MM/yyyy");

   // Estas opciones tendrán que obtenerse de algún modo.
   Map<String, Object> opciones = Map.of(
      "base", "sqlite",
      "url", "file::memory:?cache=shared",
      "user", "",
      "password", ""
   );

   // Aplicamos el patrón factory para elegir la conexión adecuada.
   Conexion conexion = BackendFactory.crearConexion(opciones);

   // Objetos para gestionar la persistencia de centros y estudiantes.
   Crud<Centro> centroDao = conexion.getCentroDao();
   Crud<Estudiante> estudianteDao = conexion.getEstudianteDao();

   Centro astaroth = new Centro(11701164, "IES Astaroth", "pública");
   centroDao.insert(astaroth);        // Hacemos persistente el centro.

   Estudiante estudiante = new Estudiante(1, "Perico de los palotes", LocalDate.parse("10/12/2010", formato), astaroth),
   estudianteDao.insert(estudiante);  // Hacemos persistente el estudiante.

   // Nos olvidamos de ambos objetos.
   centro = null;
   estudiante = null;

   estudiante = estudiante.get(1).orElse(null);   // Perico.
   astaroth = estudiante.getCentro();  // Astaroth.

   // Debemos asegurarmos de cerrar el Stream
   // para no dejar abierto el objeto Connection asociado.
   try(Stream<centro> centros = centroDao.get()) {
      centros.forEach(System.out::println);
   }

   // Borramos el centro.
   centroDao.delete(astaroth);

   centroDao.get(11701164) == Optional.empty();  // true

.. rubric:: Notas al pie

.. [#] Hemos incluido, eso sí, una anotación en el campo ``centro`` de
   ``Estudiante`` que lo identifica como clave foránea. Pero no deja de ser una
   mera anotación que además no es indispensable. Esta anotación está definida en sqlutils_.

.. [#] La ventaja de ``Stream`` es su evaluación perezosa; las desventajas son
   dos: nos veremos obligados a usar sqlutils_ y, además, se debe ser más
   cuidadoso al utilizarla ya que debemos asegurarnos de que quien cierra la
   conexión es el propio Stream.

.. [#] De todos modos, en caso de que pasáramos la conexión cuando hemos creado
   el objeto con una conexión, la conexión no se cerraría, porque la hemos
   manipulado para que no sea así (recordemos que la manejamos a través de
   ``ConnectionProvider`` y no directamente); y la sentencia quedaría sin cerrar
   hasta que no se cerrara la conexión fuera del objeto.

.. [#] En realidad, en vez de hacer una segunda consulta, podríamos hacer una
   consulta compuesta para obtener estudiante y centro.

.. _sqlutils: https://github.com/sio2sio2/sqlutils

.. |DAO| replace:: :abbr:`DAO (Data Access Object)`
.. |CRUD| replace:: :abbr:`CRUD (Create, Read, Update, Delete)`
.. |SGBD| replace:: :abbr:`SGBD (Sistema Gestor de Bases de Datos)`
.. |List| replace:: :java-util:`List <List>`.
.. |SQL| replace:: :abbr:`SQL (Structured Query Language)`.
.. |DataSource| replace:: :java-sql:`DataSource <DataSource>`.
.. |Connection| replace:: :java-sql:`Connection <Connection>`
.. |Statement| replace:: :java-sql:`Statement <Statement>`
.. |SQLException| replace:: :java-sql:`SQLException <SQLException>`
