.. _design-patterns:

Patrones de diseño
******************
Un :dfn:`patron de diseño` es una plantilla de codificación que se ha demostrado
eficaz para resolver un problema habitual. Es útil conocerlos, porque si en
nuestro programa nos enfrentamos a un problema que ya ha sido resuelto mediante
uno de estos patrones, podremos ponerlo en práctica.

En este apéndice, explicaremos algunos que 

.. _singleton-pattern:

Singleton
=========
Es un patrón que garantiza que de una clase sólo pueda existir una única
instancia.

Puede sernos muy útil,por ejemplo, si creamos una aplicación constituida por
diversos paquetes y queremos que la configuración esté disponible en todos ellos
sin tener que pasar constantemente los parámetros de configuración.

Caso simple
-----------
En Java se implementa así:

.. literalinclude:: files/Singleton.java
   :language: java
   :start-at: public class

Es decir, básicamente ocultamos el constructor para que la instancia sólo sea
accesible a través del método estático ``.getInstance``. De este modo, la única
forma de acceder al constructor es a través de ``.initialize``, pero sólo
podremos inicializar una vez.

.. tip:: Una variante de este patrón es que queramos crear no una instancia,
   sino varias, dependiendo del valor de uno de los argumentos. En ese caso, el
   atributo ``instance`` se puede convertir en un mapa cuyas claves son
   esos valores.

Programas multihilo
-------------------
En caso de que nuestro programa sea multihilo entonces tendremos que complicar
un poco el código:

.. literalinclude:: files/Singleton-synchro.java
   :language: java
   :start-at: public class


.. _factory-pattern:

*Factory*
=========
El :dfn:`patrón Factory` es un patrón utilizado para creación de objetos que se
utiliza para poder escoger en tiempo de ejecución qué objeto crear entre varios
que cumplen con una misma interfaz (o pertenecen a subclases de una misma
clase).

Implementación
--------------
Para ilustrarlo imaginemos que en nuestra aplicación necesitamos traducir datos
a distintos formatos. En una traducción básicamente hay dos operaciones:

* *Leer*, que consiste en convertir la información que está almacenada en un
  determinado formato en datos internos del programa.
* *Escribir*, que consiste transformar los datos internos al formato
  especificado.

Por tanto, queramos traducir a lo que queramos traducir, la clase reponsable
de la traducción tendrá que implementar la siguiente interfaz:

.. literalinclude:: files/Traductor.java
   :language: java
   :class: toggle
   :caption: Interface Traductor
   :start-at: public interface

en la que hemos supuesto que los datos los almacenamos en memoria en forma de
una lista. Hemos considerado una lista del ``Object`` genérico, aunque en un
ejemplo real concreto la lista será de alguna clase que hayamos definido. El
caso es que ahora definiremos diferentes clases las cuales implementarán esta
interfaz para distintos formatos (:ref:`XML <xml>`, :ref:`CSV <csv>`, :ref:`JSON
<json>`, etc.). Imaginemos que las clases se denominan ``TXml``, ``TCvs``,
``TJson``, etc.

Con todo esto, podemos poner en práctica este patrón así:

.. literalinclude:: files/TraductorFactory.java
   :language: java
   :start-at: public class

En definitiva, la clase tiene un método estático que se limita a devolver el
objeto de traducción apropiado según sea el formato. En el código principal no
habrá más que hacer lo siguiente:

.. code-block:: java

   // El formato se proporcionará de alguna manera...
   String formato = "json";

   Traductor traductor = TraductorFactory.crearTraductor(formato);

   // Suponiendo que en "data" estén los datos, esto generará una salida JSON.
   traductor.escribir(System.out, data);

Obsérvese que el código de ``TraductorFactory`` depende de qué clases
traductoras hayamos creado realmente; y, si se crea una nueva (o se elimina una
ya creada por algún motivo), habrá que editar la clase para que se refleje este
cambio. El siguiente apartado complica un poco la implementación, pero permite
escribir una clase sin esta dependencia, de manera que podemos reaprovecharla,
sea cual sea el caso.

Automatización
--------------
La idea es evitar que tengamos que escribir y reescribir la clase que
implementa el patrón Factory constantemente; y además crear un código que nos
sirva en cualquier aplicación:

.. literalinclude:: files/Factory.java
   :language: java
   :class: toggle
   :caption: Clase Factory
   :start-at: public class Factory

La principal diferencia (además de ser mucho más complicado que el anterior) es
que esta clase sí se instancia con el constructor ``Factory(Class<I>, String)``
para indicar cuál es la interfaz implementada y en qué paquete se encuentran las
clases que la implementan.  En el ejemplo de nuestros traductores:

.. code-block:: java

   Factory<Traductor> factory = new Factory<>(Traductor.class, "edu.acceso.ejemplo.traductor");

Ahora bien, si se coloca la interfaz en el mismo paquete que las clases, se
puede omitir el segundo argumento:

.. code-block:: java

   Factory<Traductor> factory = new Factory<>(Traductor.class);

La creación de este objeto *Factory* provoca que gracias a la reflexión se
analice el paquete y se localicen las clases que implementan la interfaz
(``Traductor`` en este caso). El objetivo es relacionar estas clases con su
nombre y, en su caso, con los nombres alternativos contenidos en el atributo
``alias``. Por ejemplo:

.. code-block:: java

   public class TYaml implements Traductor {
      // También podría ser String si sólo hay una alternativa
      private static final String[] alias = {"yml", "yaml"};

      // Implementación de la traducción para YAML...
   }


Esta definición relacionaría las cadenas "`tyaml`", "`yml`" y "`yaml`" con la
clase ``TYaml``, por lo que, cuando quisiéramos crear el objeto adecuado de
traducción, nos bastaría con hacer:

.. code-block:: java

   String formato = "yml"; // Por ejemplo.

   // Suponemos que Traductor y TYaml están en el mismo paquete.
   Factory<Traductor> factory = new Factory<>(Traductor.class);
   Class<? extends Traductor> traductorClass = factory.get(formato);

Y ya tendríamos disponible la clase que implementa |YAML| para instanciarla
cuando nos sea necesario. También existe la posibilidad de pedir directamente la
instancia:

.. code-block:: java

   Traductor traductor = factory.getInstance(formato);

.. caution:: Este método sólo funcionará si el constructor de las clases no
   tiene argumentos y, además, la construcción no tiene dependencias cruzadas
   en el programa. Por ejemplo, si utilizamos :ref:`una clase para gestionar la
   configuración de usuario <cliargs>` es probable que echemos mano de esta
   clase ``Factory``. Si el constructor del traductor hace
   uso a su vez de la configuración entonces tendremos una dependencia circular:
   para construir el objeto de configuración necesitamos un objeto traductor,
   pero para construir un objeto traductor necesitamos la configuración.

   Por lo general es más seguro obtener la clase del traductor e instanciar
   nosotros luego. Justamente en el caso anterior, podríamos obtener la clase
   del traductor para definir el atributo del objeto ``Config`` y en el *getter*
   de ese atributo, hacer la instanciación.

La clase tiene, además, otros dos métodos adicionales que sirven básicamente
para brindar información:

``getClasses()``
   que devuelve un mapa en que las claves son las cadenas y los valores las
   clases correspondientes.

``getAliasesByClass()``
   que devuelve un mapa en que cada clave es una clase y los valores un array
   con todos los nombres con los que está relacionada.

.. |YAML| replace:: :abbr:`YAML (YAML Ain't Markup Language)`
