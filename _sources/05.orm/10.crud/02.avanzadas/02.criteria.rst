.. _orm-criteria:

Criteria API
************
*Criteria API* es un mecanismo alternativo a |JPQL| para escribir consultas, que
es más verborreico, pero en compensación facilita la construcción dinámica de
las consultas en tiempo de ejecución, ya que no se basa en una cadena, sino en
la aplicación de métodos a objetos. Se inspiró en *Hibernate Criteria*.

Lo primero antes de construir la consulta es crear un objeto |CriteriaBuilder| a
partir del objeto :jakarta-persistence:`EntityManager`:

.. code-block:: java

   CriteriaBuilder cb = em.getCriteriaBuilder();

A partir de ahora debemos definir qué es lo que se querrá obtener (recordemos
que estamos haciendo un ``SELECT``) y sobre qué tabla/entidad se quiere hacer la
consulta. Por ejemplo:

Consulta básica
===============

Empecemos por una consulta |SQL| muy básica:

.. code-block:: java
   :name: orm-criteria-select-all
   :linenos:
   :lineno-start: 0

   // SELECT e.* FROM Estudiante e
   CriteriaQuery<Estudiante> criteria = cb.createQuery(Estudiante.class); // Obtendremos estudiantes.
   Root<Estudiante> estudiante = criteria.from(Estudiante.class); // Consultamos la entidad Estudiante
   criteria.select(estudiante); // SELECT e.* FROM Estudiante e;

   TypedQuery<Estudiante> query = em.createQuery(criteria);

Como queremos obtener objetos ``Estudiante`` (primera línea) y consultamos la
entidad ``Estudiante`` (segunda línea) es obvio que la consulta es:

.. code-block:: sql

   SELECT e.* FROM Estudiante e


Si quisiéramos obtener un campo, entonces deberíamos alterar las líneas 1 y 3:

.. code-block:: java
   :emphasize-lines: 1, 3

   CriteriaQuery<String> criteria = cb.createQuery(String.class); // Obtendremos cadenas
   Root<Estudiante> estudiante = criteria.from(Estudiante.class); // Consultamos la entidad Estudiante
   criteria.select(estudiante.get("nombre")); // SELECT e.nombre FROM Estudiante e;

   TypedQuery<String> query = em.createQuery(criteria);

Y si varios:

.. code-block:: java
   :emphasize-lines: 1, 3

   CriteriaQuery<Object[]> criteria = cb.createQuery(Object[].class);
   Root<Estudiante> estudiante = criteria.from(Estudiante.class); // Consultamos la entidad Estudiante
   criteria.multiselect(estudiante.get("nombre"), estudiante.get("centro")); // SELECT e.nombre, e.centro FROM Estudiante e;

   TypedQuery<Object[]> query = em.createQuery(criteria);

En este último caso, puede usarse también :ref:`Tuple como en JPQL <orm-tuple>`:

.. code-block:: java
   :emphasize-lines: 1, 3-6

   CriteriaQuery<Tuple> criteria = cb.createQuery(Tuple.class); // o cb.createTupleQuery();
   Root<Estudiante> estudiante = criteria.from(Estudiante.class);
   criteria.multiselect(
      estudiante.get("nombre").alias("nombre"),
      estudiante.get("centro").alias("centro")
   );

   TypedQuery<Tuple> query = em.createQuery(query);

.. tip:: Aunque, si almacenamos las definiciones de los campos, luego podremos
   recuperarlos más fácilmente sin necesidad de especificar los tipos ni hacer
   *cast*:

   .. code-block:: java
      :emphasize-lines: 3-5

      CriteriaQuery<Tuple> criteria = cb.createQuery(Tuple.class); // o cb.createTupleQuery();
      Root<Estudiante> estudiante = criteria.from(Estudiante.class);
      var nombre = estudiante.get("nombre", String.class).alias("nombre");
      var centro = estudiante.get("centro", Centro.class).alias("centro")
      criteria.multiselect(nombre, centro);

      TypedQuery<Tuple> query = em.createQuery(query);

   Lo cual nos permite hacer

   .. code-block:: java

      query.getResultList().forEach(t -> {
         String nombre = t.get(nombre);
         Centro centro = t.get(centro);
         System.out.printf("%s: %s.\n", nombre, centro)
      });


.. caution:: No es una buena práctica referir los atributos de las clases con
   una cadena (:code:`estudiante.get("nombre")`), ya que los errores de
   digitalización no pueden detectarse en tiempo de compilación. Por ese motivo,
   es bastante recomendable generar el *Metamodel*, que nos permite escribir:

   .. code-block:: java

      estudiante.get("nombre");

   como:

   .. code-block:: java

      estudiante.get(Estudiante_.nombre);

   donde ``Estudiante_`` es una clase generada por el compilador.

.. _orm-jra-metamodel:

Metamodel
=========
Para la habilitar la creación del *metamodelo*, debemos añadir a
la sección `<build>` de :file:`pom.xml`\ [#]_:

.. code-block:: xml

   <build>
      <plugins>
          <plugin>
              <groupId>org.apache.maven.plugins</groupId>
              <artifactId>maven-compiler-plugin</artifactId>
              <version>3.14.0</version>
              <configuration>
                  <release>${maven.compiler.release}</release>
                  <annotationProcessorPaths>
                      <path>
                          <groupId>org.hibernate.orm</groupId>
                          <artifactId>hibernate-processor</artifactId>
                          <version>${hibernate.version}</version>
                      </path>
                  </annotationProcessorPaths>
              </configuration>
          </plugin>
      </plugins>
   </build>

Con esto, deberíamos tener disponibles en el proyecto las metaclases
correspondientes a nuestro modelo (``Centro_`` y ``Estudiante_`` en el ejemplo).

.. caution:: Si usamos javadoc_ para la documentación, esta herramienta busca las
   clases del código fuente exclusivamente dentro de :file:`src/`, mientras que 
   las [meta]clases generadas automáticamente por hibernate-processor_ se
   incluyen en :file:`target/generated-sources/annotations/`. Esta circunstancia
   debemos indicarla:

   .. code-block:: xml
      :emphasize-lines: 10

      <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-javadoc-plugin</artifactId>
          <!-- La última versión puede consultarse en el repositorio de Maven -->
          <version>3.11.2</version>
          <configuration>
              <source>${maven.compiler.release}</source>
              <show>private</show>
              <!-- Debemos añadir annotations para que no den problemas las clases anotadas del Metamodel -->
              <sourcepath>${project.build.sourceDirectory};${project.build.directory}/generated-sources/annotations</sourcepath>
          </configuration>
      </plugin>

Ahora podríamos reescribir el ejemplo anterior así:

.. code-block:: java
   :emphasize-lines: 4, 5

   CriteriaQuery<Tuple> criteria = cb.createQuery(Tuple.class); // o
   cb.createTupleQuery();
   Root<Estudiante> estudiante = criteria.from(Estudiante.class);
   var nombre = estudiante.get(Estudiante_.nombre).alias("nombre");
   var centro = estudiante.get(Estudiante_.centro).alias("centro");
   criteria.multiselect(nombre, centro);

   TypedQuery<Tuple> query = em.createQuery(criteria);

.. note:: El *metamodel* también genera ``Estudiante_.NOMBRE`` o
   ``Estudiante_.CENTRO``, pero sólo son constantes de tipo ``String`` que se
   sustituyen por las cadenas ``"nombre"`` o ``"centro"``, allí donde están. Por
   tanto, sólo protegen de los fallos de digitalización, pero no permiten la
   comprobación estática de tipos o la refactorización de código.

Condiciones
===========
|CriteriaBuilder| tiene definidos métodos que implementan los operadores
básicos de |SQL|. Por ejemplo, para escoger los **estudiantes no matriculados**:

.. code-block:: java
   :emphasize-lines: 4

   CriteriaQuery<Estudiante> criteria = cb.createQuery(Estudiante.class);
   Root<Estudiante> estudiante = criteria.from(Estudiante.class);
   criteria.select(estudiante);
   criteria.where(cb.isNull(estudiante.get(Estudiante_.centro)));

   TypedQuery<Estudiante> query = em.createQuery(criteria);

Para obtener los estudiantes de un centro determinado (suponiendo que éste
se almacene en la variable ``centro``) la condición habría sido:

.. code-block:: java

   criteria.where(cb.equal(estudiante.get(Estudiante_.centro), centro));

Ordenación
==========
Para ordenar resultados basta con aplicar el orden a ``criteria``:

.. code-block:: java
   :emphasize-lines: 4

   CriteriaQuery<Estudiante> criteria = cb.createQuery(Estudiante.class);
   Root<Estudiante> estudiante = criteria.from(Estudiante.class);
   criteria.select(estudiante);
   criteria.orderBy(cb.desc(estudiante.get(Estudiante_.nacimiento)));

   TypedQuery<Estudiante> query = em.createQuery(criteria);

Agrupación
==========
También existe el equivalente a ``GROUP BY``:

.. code-block:: java
   :emphasize-lines: 3-7

   CriteriaQuery<Tuple> criteria = cb.createQuery(Tuple);
   Root<Estudiante> estudiante = criteria.from(Estudiante.class);
   var centro_p = estudiante.get(Estudiante_.centro);
   var centro = centro_p.alias("centro");
   var cantidad = cb.count(estudiante).alias("cantidad");
   criteria.multiselect(centro, cantidad)
      .groupBy(centro_p);

   TypedQuery<Tuple> query = em.createQuery(criteria);

Si ahora quisiéramos ordenar resultados por la cantidad de estudiantes que tiene
cada centro deberíamos añadir:

.. code-block:: java

   criteria.orderBy(cb.asc(cb.count(estudiante)));

ya que no puede usarse el alias. O, si quisiéramos ordenar por el nombre del
centro:

.. code-block:: java

   criteria.orderBy(cb.asc(estudiante.get(Estudiante_.centro).get(Centro_.nombre)));

Relaciones
==========
Como en |JPQL| también se puede relacionar fácilmente entidades.

.. rubric:: INNER JOIN o, simplemente, JOIN

Es la relación más sencilla y relaciona dos entidades en las que cada clave foránea
en una entidad hace referencia a un identificador de la otra. El resultado es
que aparecen todos los registros relacionados entre sí. Por tanto:

.. code-block:: sql

   SELECT e.*,c.* FROM Estudiante e JOIN Centro c ON e.centro = c.id;

muestra todos los estudiantes matriculados junto a los datos del centro en el
que está matriculado. La relación es conmutativa y:

.. code-block:: sql

   SELECT e.*,c.* FROM Centro c JOIN Estudiante e ON e.centro = c.id;
   
devuelve exactamente el mismo resultado. Para implementar esta relación en
*Criteria API*, podemos hacer:

.. code-block:: java
   :emphasize-lines: 4, 5

   // SELECT c.* FROM Estudiante e INNER JOIN Centro c ON e.centro = c.id; 
   CriteriaQuery<Centro> criteria = cb.createQuery(Centro.class);
   Root<Estudiante> estudiante = criteria.from(Estudiante.class);
   Join<Estudiante, Centro> centro = estudiante.join(Estudiante_.centro, JoinType.INNER);
   criteria.select(centro);

   TypedQuery<Centro> query = em.createQuery(criteria);
   query.getResultList().forEach(System.out::println);  // Imprime centros.

La segunda posibilidad, que devuelve el mismo resultado se escribe así:

.. code-block:: java
   :emphasize-lines: 4, 5

   // SELECT e.* FROM Centro c INNER JOIN Estudiante e ON e.centro = c.id;
   CriteriaQuery<Estudiante> criteria = cb.createQuery(Estudiante.class);
   Root<Centro> centro = criteria.from(Centro.class);
   Join<Centro, Estudiante> estudiante = centro.join(Centro_.estudiantes, JoinType.INNER);
   criteria.select(estudiante);

   TypedQuery<Estudiante> query = em.createQuery(criteria);
   query.getResultList().forEach(System.out::println);  // Imprime estudiantes.

pero obsérvese que requiere que hubiéramos definido la relación como
bidireccional.

.. caution:: Hemos afirmado que las consultas son equivalentes, pero no es tal,
   ya que en el primer caso hemos obtenido centros y en el segundo hemos obtenido
   estudiantes. La consulta realmente equivalen habría exigido obtener |Tuple|:

   .. code-block:: java

      // SELECT e.*, c.* FROM Estudiante e JOIN Centro c ON e.centro = c.id;
      CriteriaQuery<Tuple> criteria = cb.createQuery(Tuple.class);
      Root<Estudiante> estudiante = criteria.from(Estudiante.class);
      Join<Estudiante, Centro> centro = estudiante.join(Estudiante_.centro, JoinType.INNER);
      var estudiante_a = estudiante.alias("estudiante");
      var centro_a = centro.alias("centro");
      criteria.multiselect(estudiante_a, centro_a);

De los dos ejemplos anteriores se pueden sacar tres conclusiones:

a. La relación se establece entre una entidad y el atributo que la relaciona con
   la otra como en |JPQL| y a diferencia de lo que ocurre en |SQL|, en que se
   establece la relación entre dos tablas. Por ese motivo, el segundo ejemplo es
   imposible de llevar a cabo si no se hizo la relación bidireccional.

#. A diferencia de lo que ocurre en la consulta |SQL|, el primero de los
   ejemplos no devuelve centros duplicados, aunque varios alumnos compartan un
   mismo centro. Esto se debe al propio comportamiento de |JPA|. Por ese motivo,
   el *join* explícito no se diferencia en nada de hacer un **join implícito**
   como este:

   .. code-block:: java

      // Aunque no se exprese el JOIN, éste se realiza para obtener objetos Centro:
      // SELECT c.* FROM Estudiante e JOIN Centro c ON e.centro = c.id;
      CriteriaQuery<Centro> criteria = cb.createQuery(Centro.class);
      Root<Estudiante> estudiante = criteria.from(Estudiante.class);
      criteria.select(estudiante.get(Estudiante._centro));

      TypedQuery<Centro> query = em.createQuery(criteria);
      query.getResultList().forEach(System.out::println);  // Imprime centros.

#. Para emular el comportamiento de |SQL| y obtener centros repetidos tenemos
   que evitar obtener entidades puras:

   .. code-block:: java
      :emphasize-lines: 2, 5

      // SELECT c.* FROM Estudiante e INNER JOIN Centro c ON e.centro = c.id; 
      CriteriaQuery<Tuple> criteria = cb.createQuery(Tuple.class);
      Root<Estudiante> estudiante = criteria.from(Estudiante.class);
      Join<Estudiante, Centro> centro = estudiante.join(Estudiante_.centro, JoinType.INNER);
      var centro_a = centro.alias("centro");
      criteria.multiselect(centro_a);

      TypedQuery<Tuple> query = em.createQuery(criteria);
      query.getResultList().forEach(t -> {
         // Imprime centros repetidos.
         System.out.println("%s.\n", t.get(centro_a));
      });  

   En este último caso, podría evitarse la repetición usando ``DISTINCT``, tal
   como se hace en |SQL|:

   .. code-block:: java
      :emphasize-lines: 2

      criteria.multiselect(centro_a)
         .distinct(true);

.. rubric:: Carga inmediata

En los tres ejemplos en los que obtenemos centros (el *join* implícito, el
*join* explícito y el *join* explícito que obtiene tuplas), el hecho de que
pidamos centros provoca que estos se carguen directamente gracias a la
consulta). Sin embargo, si nuestra consulta hubiera sido aquella con la que
comenzamos a estudiar *Criteria API*:

.. code-block:: java

   // SELECT e.* FROM Estudiante e;
   CriteriaQuery<Estudiante> criteria = cb.createQuery(Estudiante.class);
   Root<Estudiante> estudiante = criteria.from(Estudiante.class);
   criteria.select(estudiante);

   TypedQuery<Estudiante> query = em.createQuery(criteria);
   List<Estudiante> estudiantes = query.getResultList();

Esos estudiantes, como consecuecia de la evaluación perezosa, no tendrían sus
centros precargados y usar ``.getCentro()`` implicaría un ``SELECT`` posterior
por cada uno de los estudiantes para obtenerlo. Añadir la línea:

.. code-block:: java

   Join<Estudiante, Centro> centro = estudiante.join(Estudiante_.centro, JoinType.INNER);

no provoca la carga inmediata, ya que no usamos luego ``centro`` en la
consulta y, por tanto, internamente, no se realiza realmente un *JOIN*.
Si nuestra intención es obligar a una carga inmediata gracias al *JOIN* interno,
debemos añadir esta línea:

.. code-block:: java
   :emphasize-lines: 4

   // SELECT e.* FROM Estudiante e INNER JOIN Centro c ON e.centro = c.id; 
   CriteriaQuery<Estudiante> criteria = cb.createQuery(Estudiante.class);
   Root<Estudiante> estudiante = criteria.from(Estudiante.class);
   estudiante.fetch(Estudiante_.centro, TypeJoin.INNER);
   criteria.select(estudiante);

   TypedQuery<Estudiante> query = em.createQuery(criteria);
   List<Estudiante> estudiantes = query.getResultList();

.. seealso:: Consulte para más información el :ref:`epígrafe dedicado a
   optimización <orm-optimo>`.

.. rubric:: LEFT JOIN

Una relación ``LEFT JOIN`` obtiene los registros relacionados entre sí (como
``INNER JOIN``) más aquellos presentes en la entidad de la izquierda que no
están relacionados con ninguno de la derecha. Debido a ello, los campos de la
derecha aparecen a ``NULL`` en estos registros adicionales. Por ese motivo:

.. code-block:: sql

   SELECT e.*,c.* FROM Estudiante e LEFT JOIN Centro c ON e.centro = c.id;

**no** equivale a:

.. code-block:: sql

   SELECT e.*,c.* FROM Centro c LEFT JOIN Estudiante e ON e.centro = c.id;
   
ya que la primera consulta, además de los estudiantes matriculados, devuelve los
no matriculados; pero no los centros sin estudiantes; mientras que la segunda
consulta devuelve los estudiantes matriculados y los centros sin estudiantes;
pero no los estudiantes no matriculados.

La primera relación se escribe en *Criteria API* así:

.. code-block:: java
   :emphasize-lines: 4, 5

   // SELECT e.*,c.* FROM Estudiante e LEFT JOIN Centro c ON e.centro = c.id;
   CriteriaQuery<Tuple> criteria = cb.createQuery(Tuple.class);
   Root<Estudiante> estudiante = criteria.from(Estudiante.class);
   Join<Estudiante, Centro> centro = estudiante.join(Estudiante_.centro, JoinType.LEFT);
   criteria.select(cb.tuple(estudiante.alias("estudiante"), centro.alias("centro")));

mientras que la segunda:

.. code-block:: java
   :emphasize-lines: 4, 5

   // SELECT e.*,c.* FROM Centro c LEFT JOIN Estudiante e ON e.centro = c.id;
   CriteriaQuery<Tuple> criteria = cb.createQuery(Tuple.class);
   Root<Centro> centro = criteria.from(Centro.class);
   Join<Centro, Estudiante> estudiante = centro.join(Centro_.estudiantes, JoinType.LEFT);
   criteria.select(cb.tuple(centro.alias("centro"), estudiante.alias("estudiante")));

Pero nótese que esta segunda requiere una relación bidireccional.

Es muy común usar ``LEFT JOIN`` para obtener indirectamente *los centros sin
alumnos matriculados*:

.. code-block:: java
   :emphasize-lines: 5

   // SELECT c.* FROM Centro c LEFT JOIN Estudiante e ON c.id = e.centro WHERE e.id IS NULL;
   CriteriaQuery<Centro> criteria = cb.createQuery(Centro.class);
   Root<Centro> centro = criteria.from(Centro.class);
   Join<Centro, Estudiante> estudiante = centro.join(Centro_.estudiantes, JoinType.LEFT);
   criteria.select(centro).where(cb.isNull(estudiante.get("id")));

.. admonition:: Advertencia

   |JPA| no define las relaciones ``RIGHT JOIN``, ya que pueden considerarse
   redundantes al ser equivalentes a una relación ``LEFT JOIN`` con las
   entidades cambiadas de orden. Pero eso, como en el ejemplo de arriba, puede
   obligarnos a tener que definir relaciones bidireccionales para determinadas
   consultas.

.. rubric:: Subconsultas
   :name: orm-subquery

*Criteria API* también ofrece la posibilidad de hacer subconsultas. De hecho, el
problema anterior podría haberse resuelto con una:

.. code-block:: sql

   SELECT c.* FROM Centro c WHERE c.id NOT IN (SELECT e.centro WHERE Estudiante e);

Esta solución, además, no obliga a hacer la relación bidireccional. Veamos cómo
implementarla con *Criteria API*:

.. code-block:: java
   :emphasize-lines: 5-7, 11

   CriteriaQuery<Centro> criteria = cb.createQuery(Centro.class);
   Root<Centro> centro = criteria.from(Centro.class);

   // Subconsulta
   Subquery<Long> subquery = criteria.subquery(Long.class) // e.centro es Long
   Root<Estudiante> subEstudiante = subquery.from(Estudiante.class);
   subquery.select(subEstudiante.get(Estudiante_.centro).get(Centro_.id));

   // Consulta con la subconsulta.
   criteria.select(centro)
      .where(cb.not(centro.get(Centro_.id).in(subquery)));

.. note:: Nótese que aquí podemos comparar directamente centros en vez de
   identificadores de centros.

O bien, si usamos el operador ``EXISTS`` de |SQL|:

.. code-block:: sql

   SELECT c.* FROM Centro c WHERE NOT EXISTS (SELECT 1 FROM Estudiante e WHERE e.centro = c.id);

que traducido a *Criteria API* queda:

.. code-block:: java
   :emphasize-lines: 5-8, 12

   CriteriaQuery<Centro> criteria = cb.createQuery(Centro.class);
   Root<Centro> centro = criteria.from(Centro.class);

   // Subconsulta
   Subquery<Long> subquery = criteria.subquery(Long.class) // 1 es Long
   Root<Estudiante> subEstudiante = subquery.from(Estudiante.class);
   subquery.select(cb.literal(1L))
      .where(cb.equal(subEstudiante.get(Estudiante_.centro).get(Centro._id), centro.get(Centro._id)));

   // Consulta con la subconsulta
   criteria.select(centro)
      .where(cb.not(cb.exists(subquery)));

.. hint:: En términos de rendimiento, de las tres alternativas presentadas la más
   eficiente es esta última:

   + ``IN`` requiere generar toda las filas de la subconsulta y, además,
     genera resultados inesperados cuando algunos de los resultados de la
     subconsulta es nulo ya que en |SQL| estándar la operación :code:`2 IN (1,
     NULL)` devuelve ``UNKNOWN`` no ``FALSE``. Justamente en este ejemplo, puede
     haber Estudiantes sin centro, por lo que tendríamos este problema y la
     alternativa **ni siquiera es válida en este caso**.

   + ``LEFT JOIN`` necesita generar todas las consultas y luego filtrar
     aquellas nulas. Esto puede generar un resultado intermedio grande que
     muchas veces lo hace menos eficiente que la alternativa con ``EXISTS``.

   + ``EXISTS`` detiene la comprobación cuando encuentra la primera
     coincidencia.

.. rubric:: Cadena de consultas

Observemos parte del código ya presentado anteriormente:

.. code-block:: java
   :emphasize-lines: 3

   CriteriaQuery<Estudiante> criteria = cb.createQuery(Estudiante.class);
   Root<Estudiante> estudiante = criteria.from(Estudiante.class);
   Join<Estudiante, Centro> centro = estudiante.join(Estudiante_.centro, JoinType.INNER);
   criteria.select(estudiante);

Partidos de ``Estudiante`` (*estudiante*) y relacionamos con ``Centro`` a través
del atributo *centro* de ``Estudiante``, de ahí que la relación se haya escrito
utilizando el objeto *estudiante*.

O sea, para relacionar con ``Centro``, *juntamos* *estudiante* (que es
``Estudiante``) a través de su atributo llamado *centro*. Si deseamos que en
la consulta participe una segunda relación, deberemos tener en cuenta con qué
entidad se relaciona. Si la tercera entidad fuera la entidad ``Grupo``
relacionada con ``Estudiante`` entonces tendríamos que hacer:

.. code-block:: java
   :emphasize-lines: 2

   Join<Estudiante, Centro> centro = estudiante.join(Estudiante_.centro, JoinType.INNER);
   Join<Estudiante, Curso> curso = estudiante.join(Estudiante_.curso, JoinType.INNER);

En cambio, si la tercera entidad fuera la entidad ``ComunidadA`` relacionada con
``Centro``, entonces la relación se establecería así:

.. code-block:: java
   :emphasize-lines: 2

   Join<Estudiante, Centro> centro = estudiante.join(Estudiante_.centro, JoinType.INNER);
   Join<Centro, ComunidadA> comunidad = centro.join(Centro_.comunidad, JoinType.INNER);

Actualización y borrado
=======================
Al igual que |JPQL|, también se puede **actualizar** objetos. Por ejemplo, esto
desmatricularía a todos los estudiantes cuyo nombre empieza por "J":

.. code-block:: java

   // UPDATE Estudiante SET centro = NULL WHERE nombre LIKE 'J%';
   CriteriaUpdate<Estudiante> update = cb.createCriteriaUpdate(Estudiante.class);
   Root<Estudiante> estudiante = update.from(Estudiante.class);
   update.set(estudiante.get(Estudiante_.centro), null);
   update.where(cb.like(estudiante.get(Estudiante_.nombre), "J%"));

   em.createQuery(update).executeUpdate();

También es posible **borrar**:

.. code-block:: java

   // DELETE FROM Estudiante WHERE nombre LIKE 'J%';
   CriteriaDelete<Estudiante> delete = cb.createCriteriaDelete(Estudiante.class);
   Root<Estudiante> estudiante = delete.from(Estudiante.class);
   delete.where(cb.like(estudiante.get(Estudiante_.nombre), "J%"));

   em.createQuery(delete).executeUpdate();

.. rubric:: Notas al pie

.. [#] Si utilizáramos otros |ORM| tendríamos que cambiar la referencia al |ORM|
       dentro de ``<annotationProcessorPaths>``. Para **EclipseLink**:

       .. code-block:: xml

          <annotationProcessorPaths>
              <path>
                  <groupId>org.eclipse.persistence</groupId>
                  <artifactId>org.eclipse.persistence.jpa.modelgen.processor</artifactId>
                  <version>${eclipselink.version}</version>
              </path>
          </annotationProcessorPaths>
         
       Y para **OpenJPA**:

       .. code-block:: xml

          <annotationProcessorPaths>
              <path>
                  <groupId>org.apache.openjpa</groupId>
                  <artifactId>openjpa</artifactId>
                  <version>${openjpa.version}</version>
              </path>
          </annotationProcessorPaths>

.. |JPQL| replace:: :abbr:`JPQL (Java Persistence Query Language)`
.. |SQL| replace:: :abbr:`SQL (Structured Query Language)`
.. |ORM| replace:: :abbr:`ORM (Object-Relational Mapping)`
.. |JPA| replace:: :abbr:`JPA (Java Persistent API)`

.. |CriteriaBuilder| replace:: :jakarta-persistence:`CriteriaBuilder <criteria/criteriabuilder>`
.. |Tuple| replace:: :jakarta-persistence:`Tuple <Tuple>`

.. _hibernate-processor: https://mvnrepository.com/artifact/org.hibernate.orm/hibernate-processor
.. _javadoc: https://javadoc.io
