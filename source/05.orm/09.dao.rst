.. _orm-pattern:

Estrategias de diseño
=====================
Cuando analizamos :ref:`conectores <conn>`, ya expusimos que uno de los patrones
de diseño más socorridos es el patrón |DAO|. Al usar un |ORM| podríamos seguir
esa misma estrategia y definir una interfaz |CRUD| para crear clases |DAO| para
todas las entidades del modelo. En este caso, la única salvedad es que las
implementaciones de los métodos de la interfaz no se basarían en |JDBC| sino en
|JPA|. Ahora bien, muy comúnmente y a menos que nuestra intención sea
reaprovechar una interfaz antigua implementada con |JDBC|, obrar de esta manera
es un poco redundante, ya que el propio |JPA| tiene una orientación semejante a
|DAO|.

Lo que sí es muy conveniente es intentar liberar al resto del código de las
particularidades del acceso, así que conviene encerrarlas en una clase auxiliar.
Podríamos proponer esta:

.. literalinclude:: files/JpaBackend.java
   :class: toggle
   :caption: JpaBackend.java
   :language: java
   :start-at: public class

Esta clase posibilita la creación de un único objeto por por unidad de
persistencia. Cada una de estas fábricas se asocia al nombre de la unidad de
persistencia para que podamos recuperarlas posteriormente cuando nos sean
necesarias:

.. code-block:: java

   public static main(String[] args) throws Exception {}
      // Propiedades configuradas en tiempo de ejecución.
      Map<String, String> props = new HashMap<>();
      props.put("jakarta.persistence.jdbc.url", "jdbc:sqlite:centro.db");
      props.put("hibernate.show_sql", "true");

      JpaBackend.createEntityManagerFactory("MiUnidadP", props);

      // ...

      try(EntityManagerFactory emf = JpaBackend.getEntityManagerFactory("MiUnidadP")) {
         operaciones(idx);  // Aquí se crean y usan objetos EntityManager
      }
   }

   private static void operaciones(int idx) {
      // ¡Ojo! No hay que cerrarlo.
      EntityManagerFactory emf = JpaEmFactory.getInstance("MiUnidadP"); // Devuelve el mismo objeto.

      try(em EntityFactory = emf.createEntityManager()) {
         EntityTransaction tr = em.getTransaction();
         try {
            tr.begin();
            Centro centro = new Centro(11004866, "IES Castillo de Luna", Centro.Titularidad.PUBLICA);
            em.persist(centro);
            tr.commit();
         }
         catch(Exception e) {
            if(tr != null && tr.isActive()) tr.rollback();
            throw new RuntimeException("Error al almacenar el centro", err);
         }
      }
   }

.. tip:: Se ha permitido también que en caso de que sólo se haya creado una
   fábrica, ni siquiera sea necesario facilitar el índice:

   .. code-block:: java

      try(EntityManagerFactory emf = JpaBackend.getEntityManagerFactory()) {
         operaciones();
      }

Obtener la fábrica, sin embargo, nos obligaría a crear objetos
:jakarta-persistence:`EntityManager` y a gestionar correctamente las
transacciones con lo que no abstraería el código de las particularidades del
almacenamiento. Por ese motivo la clase incluye algunos métodos para manejar
automáticamente las transacciones:

.. code-block:: java

   // Podríamos obviar el nombre de la unidad de persistencia, si sólo hubiera una fábrica.
   JpaBackend.transaction("MiUnidadP", em -> {
      Centro centro = new Centro(11004866L, "IES Castillo de Luna", Centro.Titularidad.PUBLICA);
      em.persist(centro);
   });


   // Este método es capaz de devolver lo que devuelve la función del argumento.
   // Como en el caso anterior, se puede obviar el índice 1.
   Centro otro = JpaBackend.transactionR("MiUnidadP", em -> em.get(Centro.class, 11004866L));


.. |DAO| replace:: :abbr:`DAO (Data Access Object)`
.. |CRUD| replace:: :abbr:`CRUD (Create, Read, Update, Delete)`
.. |JDBC| replace:: :abbr:`JDBC (Java DataBase Connectivity)`
.. |ORM| replace:: :abbr:`ORM (Object-Relational Mapping)`
.. |JPA| replace:: :abbr:`JPA (Java Persistence API)`

.. _patrón Singleton: https://es.wikipedia.org/wiki/Singleton
