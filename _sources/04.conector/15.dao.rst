.. _conn-prog:

Programación con conectores
***************************
Como se ha podido ver hasta aquí, el acceso de una aplicación a una base de
datos relacional es relativamente sencillo y medianamente semejante sea cual
sea el lenguaje de programación y el |SGBD|. Por tanto, el usar de modo básico
conectores no entraña excesiva dificultad. Lo complicado, en realidad, es
abstraer al resto del programa del acceso, de modo que logremos que manipule
puramente objetos, aunque la información no esté almacenada según este modelo
en la base de datos.

Así pues, el propósito a seguir cuando se codifica una aplicación es que todas
las particularidades del acceso a datos estén reducidas a un paquete dentro de
la aplicación (p.ej. llamado *backend*), fuera del cual no haya otra cosa que
objetos.

Patrón |DAO|
============

Uno de los patrones más usados para lograr la abstracción es el `patrón DAO
<https://www.baeldung.com/java-dao-pattern>`_, que se carga de tomar los objetos
de la capa de negocio y transladarlos al soporte de persistencia o viceversa.
Retomando el ya manido :ref:`ejemplo de centros y alumnos <ej-centros-alumnos>`:

.. image:: files/DAO.png
   :name: dia-dao

Este patrón básicamente:

+ Define una interfaz para establecer las operaciones |CRUD| y, quizás, algunas
  consultas más específicas.
+ Define clases (``CentroDAO``, ``EstudianteDAO``) que implementan la interfaz
  anterior para el soporte de datos que utilice la aplicación, el cual
  forzosamente no tiene por qué ser una base de datos relacional. Un cambio en
  el soporte implica rehacer estas implementaciones, sin alterar el resto de la
  aplicación.
+ El resto de la aplicación se encarga de utilizar la interfaz, por lo que es
  ajena a la implementación para un soporte particular.

.. seealso:: Todo el código que se describe y comenta en este apartado está en el
   `repositorio de GitHub TestDAO <https://github.com/josem-dam/TestDAO>`_. Se
   recomienda descargarlo para repasar mejor las explicaciones.

Por lo general, aunque no forzosamente, cada clase del modelo tendrá asociada
una clase |DAO|. Recordemos las clases del modelo (``Centro`` y
``Estudiante``), aunque en esta ocasión para intentar uniformizar la
implementación forzaremos a que ambas deriven de una interfaz que nos asegura que
ambas manejan de igual modo su identificador:

.. literalinclude:: files/Entity.java
   :name: clase-Entity

La clase :ref:`Centro <clase-centro>` ya se definió anteriormente.
``Estudiante`` es esta otra:

.. literalinclude:: files/Estudiante.java
   :language: java
   :name: clase-estudiante
   :class: toggle
   :caption: Estudiante.java
   :start-at: public class

Este es el modelo. Ahora necesitamos implementar el acceso a los datos. Eso
requiere definir la interfaz para las operaciones |CRUD|, que en un alarde de
originalidad llamaremos ``Crud``, y dos clases |DAO|, ``CentroSqlDAO`` y
``EstudianteSqlDAO``. La interfaz podemos establecerla como estimemos mejor,
mientras recoja todas las operaciones necesarias. Por ejemplo:

.. literalinclude:: files/Crud.java
   :language: java
   :class: toggle
   :name: clase-crud
   :caption: Crud.java
   :start-at: public interface

.. admonition:: Aclaración

   Esta interfaz no tiene por qué ser definida exactamente así: podría definirse
   otra que satisfaga también la necesidad de implementar las cuatro operaciones
   básicas. Por ejemplo, los métodos que obtienen todas las entidades de un tipo
   podrían devolverlas en forma de |Stream| en vez de |List|.

Como puede comprobarse, tanto las definiciones de las clases como la interfaz
son independientes de cuál sea el soporte de almacenamiento y responden las
primeras a la lógica de la aplicación y la segunda a la necesidad de obtención
de datos almacenados.

Nótese que la interfaz es genérica, porque tiene que servir para cualquier tipo
de objeto que quiera almacenarse en la base de datos. En nuestro ejemplo, se
particularizará para :ref:`Centro <clase-centro>` y para :ref:`Estudiante
<clase-estudiante>`.

Llegamos por fin a la parte en la que implementamos la lógica de la
persistencia. Necesitamos, en principio, tres clases: una que abstraiga del
establecimiento de la conexión, que bien podría ser :ref:`ConnectionPool
<ConnectionPool>` ) (o una clase más específica de nuestra aplicación que
la use), y otra por cada una de las clases del modelo:

.. table::
   :name: clase-dao

   ================== ================== ============================================
    Clase del modelo   Clase del patrón   Descripción
   ================== ================== ============================================
    \-                 ConnectionPool     Se encarga de establecer la conexión.
    Centro             CentroSqlDao       Acceso a la tabla Centro.
    Estudiante         EstudianteSqlDao   Acceso a la tabla Estudiante.
   ================== ================== ============================================

Si suponemos que en estas clases |DAO| definimos un método ``.getConnection()`` que
nos proporciona una objeto |Connection| para hacer la operación, la
implementación de cada operación es trivial si hemos llegado leyendo la unidad
hasta aquí. Por ejemplo:

.. code-block:: java
   :emphasize-lines: 5
   :name: dao-delete

   @Override
   public boolean delete(Long id) throws DataAccessException {
      String sqlString = "DELETE FROM Centro WHERE id_centro = ?";

      try(Connection conn = getConnection()) {
          try(PreparedStatement pstmt = conn.prepareStatement(sqlString)) {
              pstmt.setLong(1, id);
              return pstmt.executeUpdate() > 0;
          }
      }
      catch(SQLException e) {
          throw new DataAccessException("Imposible borrar el centro", e);
      }
   }

El método (que implementa el método de borrado que declara ``Crud<T>``) no tiene
ninguna dificultad y todos los demás tendrán un aspecto semejante. El verdadero
problema realmente lo hemos soslayado: el método ``getConnection()``. ¿Cómo
obtenemos la conexión?

Podríamos pensar en pasar una conexión al constructor para tenerla disponible
durante la vida del objeto |DAO|, pero eso nos obligaría a rescribir el código
anterior para no cerrar la conexión. O podríamos pasar al constructor un
|DataSource| y que el método creara un objeto |Connection| cada vez que lo
invocamos, así podríamos dejar el código como está. Pero esto tendría un
problema añadido: cada operación abriría y cerraría su propia conexión, lo que
impide que dos o más operaciones puedan constituir una única transacción.

La solución, en realidad, ya la tenemos: nuestro :ref:`gestor de transacciones
<conn-transaction-manager>`: es multihilo y, además, puede definirse uno
distinto por cada |DataSource| que necesitemos con tan solo asociarlo a una
clave. Por otro lado, lo construimos de manera que protege a la conexión contra
cierres accidentales ya que del cierre se encarga en exclusiva el propio gestor
al cerrar la transacción. En conclusión, que nos usarlo en nuestra
implementación del patrón |DAO|. Para simplificar las cosas definamos un |DAO|
abstracto del que deriven los |DAO| para cada objeto:

.. literalinclude:: files/BaseDao.java
   :language: java
   :caption: BaseDao.java (:download:`descarga <files/BaseDao.java>`)
   :start-at: public abstract class

Es decir, construimos las clases |DAO| pasando la clave que identifica al
|DataSource| (en realidad, el objeto :ref:`ConnectionPool <ConnectionPool>`) que nos
interesa; y, como ya adelantamos, la conexión la obtenemos del gestor de
transacciones.

.. caution:: Esto obliga a que cualquier operación, aunque sea única la llevemos
   a cabo dentro de una transacción.

Ahora podemos codificar las dos clases DAO que implementan la interfaz
|CRUD|:

.. literalinclude:: files/CentroSqlDao.java
   :language: java
   :class: toggle
   :name: clase-centrosqldao
   :caption: CentroSqlDao.java
   :start-at: public class

.. note:: Como la clase es tan sencilla (también la relativa a ``Estudiante``),
   usa |SQL| estándar y, por consiguiente, el código no depende del |SGBD|
   particular. De ahí que hayamos elegido nombres que hacen referencia a |SQL| y
   no a :program:`SQLite`.

Y ``EstudianteSqlDao`` se implementará de modo análogo.

¿Cómo podríamos usar estas clases? Más o menos así:

.. code-block:: java

   try(ConnectioPool cp = ConnectionPool.create("DB", dbUrl, dbUser, dbPassword)) {
      cp.setTransactionManager();

      // Este DAO ya sabe con qué gestor de transacciones está relacionado.
      CentroDao centroDao = new CentroDao("DB");

      cp.getTransaction().transaction(conn -> {
         Centro astaroth = new Centro(11701164L, "IES Astaroth",Titularidad.PUBLICA);
         centroDao.insert(astaroth);  // Usa la conexión asociada a la transacción.
      });
   }

Finalmente hay un último detalle para el cual conviene que mostremos la
implementación de ``EstudianteSqlDao``:

.. literalinclude:: files/EstudianteSqlDao.java
   :language: java
   :name: clase-estudiantesqldao
   :class: toggle
   :caption: EstudianteSqlDao.java
   :emphasize-lines: 31

El detalle por revisar es la relación entre ``Estudiante`` y ``Centro``. En el
código se resuelve de la manera más sencilla posible: al cargar un objeto
``Estudiante`` también se carga el objeto ``Centro`` al que está asociado, ya
que una carga perezosa, esto es, que el centro se cargue sólo cuando se requiere
de forma efectiva con su *getter* correspondiente, complica mucho el código.

.. note:: Esta solución no es muy purista, ya que los objetos |DAO| no son
   independientes entre sí. Una mejor solución sería resolver la relación
   haciendo una única consulta a la base de datos que cargue ambas entidades a
   la vez:

   .. code-block:: sql

      SELECT e.id_estudiante AS e_id, e.nombre AS e_nombre, e.nacimiento AS e_nacimiento,
             p.*
      FROM Estudiante e JOIN Centro c ON e.id_estudiante = c.id;

Conclusiones
============
Toca para cerrar enumerar algunas conclusiones a las que hemos llegado:

+ Es indispensable usar un **pool de conexiones** para mejorar el rendimiento. De
  este modo, podemos cerrar las conexiones según la lógica de la aplicación sin
  preocuparnos  de la penalización del rendimiento.
+ El soporte para **transacciones** es indispensable.
+ Debe separarse el acceso a la fuente de datos del resto de la aplicación. Un
  patrón muy socorrido, sobre todo en bases de datos, es el patrón |DAO|.
+ Gran parte de los retos que debemos resolver al programar con *conectores*, ya
  los resuelven las :ref:`herramientas ORM <orm>`, que trataremos a
  continuación, por lo que en muchas ocasiones en las que o bien el
  programador no es avezado o bien, aunque lo sea, el rendimiento no es crítico,
  es más inteligente utilizarlas.

.. _sqlutils: https://github.com/sio2sio2/sqlutils
.. _Singleton: https://es.wikipedia.org/wiki/Singleton
.. _Multiton: https://en.wikipedia.org/wiki/Multiton

.. |DAO| replace:: :abbr:`DAO (Data Access Object)`
.. |CRUD| replace:: :abbr:`CRUD (Create, Read, Update, Delete)`
.. |SGBD| replace:: :abbr:`SGBD (Sistema Gestor de Bases de Datos)`
.. |Stream| replace:: :java-util:`Stream <stream/Stream>` 
.. |List| replace:: :java-util:`List <List>`
.. |SQL| replace:: :abbr:`SQL (Structured Query Language)`
.. |URL| replace:: :abbr:`URL (Uniform Resource Locator)`
.. |DataSource| replace:: :javax-sql:`DataSource <DataSource>`
.. |Connection| replace:: :java-sql:`Connection <Connection>`
.. |Statement| replace:: :java-sql:`Statement <Statement>`
.. |SQLException| replace:: :java-sql:`SQLException <SQLException>`
.. |Consumer| replace:: :java-function:`Consumer <Consumer>`
